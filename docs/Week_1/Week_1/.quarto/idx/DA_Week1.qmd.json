{"title":"Week 1: Visualising data using R","markdown":{"yaml":{"title":"Week 1: Visualising data using R","format":{"html":{"code-link":true,"code-fold":true,"code-tools":{"source":false,"toggle":true},"toc":true,"toc-location":"left","toc-title":"Contents","number-sections":true},"pdf":{"latex-auto-install":true}},"editor":"visual","editor_options":{"chunk_output_type":"console"}},"headingText":"Getting started","containsRefs":false,"markdown":"\n\n\nThis week we will demonstrate various techniques for visualising data in R using `ggplot2`. This will also include the correct interpretation and understanding of the different plotting techniques.\n\n::: callout-note\nA lot of the content within this course is based on the open-source book [An Introduction to Statistical and Data Science via R](https://moderndive.com/index.html) and thus is a useful source for additional examples and questions.\n:::\n\nFirst, start by opening **RStudio** by going to `Desktop -> Maths-Stats -> RStudio`. Once RStudio has opened create a new R script by going to `File -> New File -> R Script`. Next go to `File -> Save As...` and save the script into your personal drive, either `M:` or `K:` (do not save it to the `H:` drive). We shall now load into R all of the libraries we will need for this session. This can be done by typing the following into your R script:\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(ggplot2)\nlibrary(nycflights13)\n```\n\nThe libraries can be loaded into R by highlighting them in your script and then clicking on the `Run` button located in the top right of the script window. The first library `ggplot2` allows us to use functions within that package in order to create nicer data visualisations. The second library `nycflights13` contains data on flights from New York City in 2013 that we shall be examining.\n\n# Viewing the data\n\nBefore visualising any data set, we first need to know its contents. For example, the contents of the `flights` data within the `nycflights13` library can be observed using the following command:\n\n```{r}\nhead(flights, n = 3)\n```\n\nThis prints to the R console the first `n = 3` rows of the `flights` data set, displaying each of the variables within said data set. We now know the data set contains `r ncol(flights)` variables, as well as their names. A quick check on the size of a data set can be obtained using:\n\n```{r}\ndim(flights)\n```\n\nwhich displays the dimensions of the data set. Thus, here we have `r nrow(flights)` rows and `r ncol(flights)` columns worth of data.\n\nTo reduce the amount of data we will be working with and make things a little easier, let's only look at *Alaska Airlines* flights leaving from New York City in 2013. This can be done by subsetting the data in such a way that we only observe flights from Alaska Airlines (carrier code AS), as follows:\n\n```{r alaska, echo = TRUE, eval = TRUE}\nAlaska <- flights[flights$carrier == \"AS\", ]\n```\n\nThis essentially picks out all of the rows within the `flights` data set for which the carrier code is `AS` and discards the rest, thus creating a new data set entitled `Alaska`. Next week we will look at more sophisticated ways of manipulating data sets. Now, let us go on to look at different visualisations of our `Alaska` data set using `ggplot2`, starting with **scatterplots**.\n\n# Scatterplots\n\nThe first data visualisation technique we introduce is the **Scatterplot** (or bivariate plot), which allows for two variables to be plotted against one another, with one plotted on the x-axis, and the other on the y-axis. This allows us to examine if there is any relationship between the two variables, such as positive or negative correlation, and whether the relationship appears linear or not. Let's say we wanted to observe the relationship between departure and arrival delays. We can do that in R using the `ggplot` function. First, we can set up the plotting region for our scatterplot of departure against arrival delays as follows:\n\n```{r ggplot, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Plot with no layers.\", out.width = '50%',message=FALSE,warning=FALSE}\nggplot(data = Alaska, \n       mapping = aes(x = dep_delay, y = arr_delay)) \n```\n\nHere, we have set up our plotting region by giving to the `ggplot` function:\n\n1.  The data `Alaska` by setting `data = Alaska`.\n2.  The mapping of the coordinates for the axes using `aes(x = dep_delay, y = arr_delay)`, where `aes()` relates to the plots aesthetics. That is,\n    -   `dep_delay` maps to the `x` coordinate; and\n    -   `arr_delay` maps to the `y` coordinate.\n\nIn order to include the points on the scatterplot we now need to add an additional layer using the `+` command. A layer combines data, aesthetic mapping, a geom (geometric object), a stat (statistical transformation), and a position adjustment:\n\n```{r}\n#| eval: false\n#| code-fold: show\n  layer(\n  mapping = NULL, \n  data = NULL,\n  geom = \"point\", \n  stat = \"identity\",\n  position = \"identity\"\n)\n```\n\nThe points are then added by creating a points layer:\n\n```{r ggplot2, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Relationship between arrival and departure delays.\"}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_point()\n```\n\nwhere `geom_point` specifies that the geometric objects to add to our plotting region are points.\n\nWhen adding layers using `ggplot` it should be noted that:\n\n-   the `+` command should come at the end of lines, otherwise R will produce an error.\n-   when adding additional layers it is a good idea to take a new line after each `+` command. This is so your code will be nice and clear with each layer given its own line of code. This is handy for code debugging.\n\nWe can change the axes labels and include a title on our plot by adding another layer as follows:\n\n```{r ggplot3, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Relationship between arrival and departure delays with nice labels.\", out.width = '65%'}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_point() +\n  labs(x = \"Departure delay (minutes)\", y = \"Arrival delay (minutes)\",\n       title = \"Alaska Airlines flights leaving NYC in 2013\") \n```\n\n## Over-plotting\n\nFrom our scatterplot it is clear to see that the vast majority of the points lie close to zero for both departure and arrival delays. This can make it difficult at times to observe what is going on. This is due to so many points being plotted very close to each other, and often plotted over one another in such a way that it is impossible to count how many points are actually plotted. This is referred to as **over-plotting**. Using `ggplot`, there are two ways we can address this problem:\n\n1.  adjust the transparency of the plotted points using the `alpha` argument.\n2.  jitter the points using the `geom_jitter` function.\n\n### Adjust transparency\n\nWe shall first alter the transparency of the points and see if this improves the situation. This is done as follows:\n\n```{r ggplot4, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Relationship between arrival and departure delays with alpha = 0.2.\"}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_point(alpha = 0.2) +\n  labs(x = \"Departure delay (minutes)\", y = \"Arrival delay (minutes)\",\n       title = \"Alaska Airlines flights leaving NYC in 2013\") \n```\n\nThe `alpha` command ranges between 0 and 1, where 0 relates to 100% transparency, while 1 (default) sets the points to be 100% opaque. By changing the transparency levels of the points we can observe clusters of points that are close to one another as they will be darker than areas of the plot with fewer points clustered together.\n\n### **Jittering**\n\nThe idea behind jittering is that each point is randomly moved, or nudged, slightly from its original position in such a way that clusters of points with the same coordinates can be observed, instead of being plotted on top of one another. To understand this, let's create a small data set consisting purely of zeros, such that:\n\n```{r jitter example, echo = TRUE, eval = TRUE}\njitter.example <- matrix(0, nrow = 10, ncol = 2)\n```\n\nThis basically creates a `r nrow(jitter.example)` by `r ncol(jitter.example)` matrix of zeros. You can look at it in the console by simply typing:\n\n```{r jitter example2, echo = TRUE, eval = FALSE}\njitter.example\n```\n\nNow, `ggplot` only works with data frames and not matrices, so we need to convert `jitter.example` into a data frame. This can be done using:\n\n```{r jitter example3, echo = TRUE, eval = TRUE}\njitter.example <- as.data.frame(jitter.example)\n```\n\nThere are functions within R that can be used to determine whether an object is a matrix or a data frame. See\n\n```{r is examples, echo = TRUE, eval = FALSE}\n?is.matrix\n?is.data.frame\n```\n\nNow, let's plot our toy example:\n\n```{r jitter example4, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Jitter example data scatterplot.\", out.width = '50%'}\nggplot(data = jitter.example, mapping = aes(x = V1, y = V2)) + \n  geom_point()\n```\n\nNote that since changing `jitter.example` into a data frame, the columns have been given the default variable names `V1` and `V2`. From the plot, if you had never seen our toy example before you would think only a single value was plotted due to them all being zero. If we shift each of the points slightly using jittering we will be able to see them more clearly:\n\n```{r jitter example5, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Jittered scatterplot of jitter example data.\", out.width = '50%'}\nggplot(data = jitter.example, mapping = aes(x = V1, y = V2)) + \n  geom_jitter(width = 0.1, height = 0.1)\n```\n\nNote that `geom_jitter` has replaced `geom_point`. Now we can clearly see all 10 observations plotted. The amount of horizontal and vertical jittering of the points is controlled by the `width` and `height` arguments within `geom_jitter`.\n\nNow that we understand the idea behind jittering, let's produce a jittered scatterplot of the `Alaska` data:\n\n```{r ggplot5, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Jittered scatterplot of arrival and departure delays.\"}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_jitter(width = 30, height = 30) +\n  labs(x = \"Departure delay (minutes)\", y = \"Arrival delay (minutes)\",\n       title = \"Alaska Airlines flights leaving NYC in 2013\") \n```\n\nNow we can see more of the points plotted within the cluster of points around (0,0). However, since this cluster is so large, it can be argued that jittering has not helped much here. Also, it is important to add enough jitter in order to separate the overlapping of points, however, not so much that we lose any pattern observed within the points. It should also be noted that jittering does not change the actual values of the points within the data set, it is merely used to help with visualising the data.\n\n# Histograms\n\nHistograms allow us to look at the *statistical distribution* of a variable. They show us how many values of a variable fall within specified *bins*. These bins give ranges of values for which the variable lies. The bins can be altered, that is, by changing their width, or by increasing the number of bins, such that we see the distribution at a higher resolution.\n\nHere, let's take a look at the `weather` data set that is within the `nycflights13` library. This data set contains hourly weather data from three airports (LGA, JFK and EWR) in New York City in 2013. We can look at its contents via:\n\n```{r weather, echo = TRUE, eval = TRUE, warning = FALSE}\nhead(weather, n = 3)\n```\n\nTo create a histogram using `ggplot` we use the `geom_histogram` command, or layer, instead of `geom_point` as with scatterplots. We can create a histogram of the hourly temperature data in NYC in 2013 using `ggplot` as follows:\n\n```{r hist6, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013.\", out.width = '51%'}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram()\n```\n\nHere, `ggplot` tells us that it used 30 bins when creating the histogram. We can adjust the bins in `ggplot` using two different approaches. Either by adjusting the\n\n-   number of bins using the `bins` argument; or\n-   the width of the bins using the `binwidth` argument.\n\nLet's first start by specifying the number of bins as follows:\n\n```{r hist7, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013 (with 60 bins).\", out.width = '51%'}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(bins = 60, color = \"white\")\n```\n\nNote, we also specified the outline colour of the bins to make it easier to differentiate between them. The colour of the bins themselves can be changed by including the `fill` argument. The colour options available can be found by typing the following into the R console:\n\n```{r hist8, echo = TRUE, eval = FALSE}\ncolors()\n```\n\nInstead of specifying the number of bins, we can specify their width using `binwidth` as follows:\n\n```{r hist9, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013 (using binwidth).\"}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(binwidth = 5, color = \"white\")\n```\n\nFinally, we can give the histogram a title and clean up the labels to make them more informative.\n\n**Try recreating the following histogram by setting `bins = 60` and `fill = 'skyblue'`**\n\n```{r hist10, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013 with updated labels.\"}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(bins = 60, color = \"white\", fill = \"skyblue\") +\n    labs(x = \"Temperature (Hourly)\",\n          title = \"Hourly temperatures from NYC in 2013\") \n```\n\n`r hide(\"I need a hint\")`\n\nSee the documentation for `geom_histogram()` (`?geom_histogram`)\n\n`r unhide()`\n\n<!-- note: you could also just set webex.hide to TRUE -->\n\n```{r, echo = TRUE, eval = FALSE}\n#| webex.hide: \"Click here to see the solution\"\n#| code-fold: show\n\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(bins = 60, color = \"white\", fill = \"skyblue\") +\n    labs(x = \"Temperature (Hourly)\",\n          title = \"Hourly temperatures from NYC in 2013\") \n```\n\n# Boxplots\n\nAnother way to look at the distribution of a variable is using a **boxplot**. A boxplot makes use of the standard *five-number summary*, that is\n\n-   the minimum value;\n-   the first quartile or 25th percentile;\n-   the median (or 2nd quartile / 50th percentile);\n-   the third quartile or 75th percentile;\n-   and the maximum value.\n\nKeeping with the hourly temperature data, the five-number summary can be obtained in R using the following command:\n\n```{r summary, echo = TRUE, eval = TRUE, warning = FALSE}\nsummary(weather$temp)\n```\n\nThis provides us with the five-number summary, as well as the `mean` hourly temperature. There is one missing value in the hourly temperature data, which is represented in R by `NA`.\n\nThe boxplot of the hourly temperature data is plotted below.\n\n```{r boxplot, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = \"Boxplot of hourly temperature recordings from NYC in 2013.\"}\nboxplot(weather$temp, ylab = \"Hourly Temperature\",\n        main = \"Hourly temperatures from NYC in 2013\")\ntext(x= 1.35, y= summary(weather$temp)[1], labels= \"Minimum\")\ntext(x= 1.35, y= summary(weather$temp)[2], labels= \"1st quartile\")\ntext(x= 1.35, y= summary(weather$temp)[3], labels= \"Median\")\ntext(x= 1.35, y= summary(weather$temp)[5], labels= \"3rd quartile\")\ntext(x= 1.35, y= summary(weather$temp)[6], labels= \"Maximum\")\n```\n\nThe elements of the boxplot relating to the five-number summary have also been labelled. Other features of the boxplot are:\n\n-   the *interquartile range (IQR)*, that is, the height of the box (3rd - 1st quartiles), and is a measure of the spread of the middle 50% of values. Longer boxes are indicative of greater variability.\n-   The dashed lines are known as *whiskers* and represent values less than the 25th percentile, and greater than the 75th percentile, respectively. The longer the whiskers, the more variability there is outside of the middle 50%.\n\nBoxplots are useful visualisations when comparing the distribution of a numerical variable split across groups (or a *categorical variable*). For example, we could look at how the hourly temperature changes by month, where month is our categorical, or grouping, variable.\n\nTo create boxplots using `ggplot` we use the `geom_boxplot` function. If we want to look at boxplots of a variable separately for a categorical variable then we need to introduce the `factor` function. This converts a numerical variable into a categorical one, essentially creating labels or categories from the numeric values. For example, the `month` variable within the `weather` data set is a numerical variable taking on the values 1,$\\ldots$,12, for each month. However, it makes more sense to convert this into a categorical variable using the `factor` function, such that:\n\n```{r boxplot5, echo = TRUE, eval = FALSE}\nweather$month\n```\n\n```{r boxplot6, echo = FALSE, eval = TRUE}\nweather$month[1:10]\n```\n\nbecomes\n\n```{r boxplot7, echo = TRUE, eval = FALSE}\nfactor(weather$month)\n```\n\n```{r boxplot8, echo = FALSE, eval = TRUE}\nfactor(weather$month)[1:10]\n```\n\nwith levels, or categories, 1,$\\ldots$,12 for each month. Hence, the boxplots can be produced using `ggplot` as follows:\n\n```{r boxplot9, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Boxplots of hourly temperature recordings from NYC in 2013 by month.\"}\nggplot(data = weather, mapping = aes(x = factor(month), y = temp)) +\n  geom_boxplot(fill = \"steelblue\") +\n  labs(x = \"Month\", y = \"Temperature (Hourly)\",\n        title = \"Hourly temperatures from NYC in 2013 by month\")  +\n  scale_x_discrete(labels = c(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                              \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"))\n```\n\nNote, we have introduced a new function `scale_x_discrete`, which is used to rename the labels of the boxplots. This function is used as our categorical variables are discrete in nature. After splitting the hourly temperatures by month, we now see points extending beyond the whiskers of the boxplots. These are known as *outliers*, and may be thought of as unusually small or large values. However, the definition of an outlier here is somewhat arbitrary as they are defined by the length of the whiskers, which are no more than 1.5 x *IQR*.\n\n**Try modifying the boxplot above by having a different fill color for each month.**\n\n`r hide(\"I need a hint\")`\n\nUse the `fill` aesthetic to declare the variable you want to colour\n\n`r unhide()`\n\n```{r, echo = TRUE, eval = FALSE}\n#| webex.hide: \"Click here to see the solution\"\n#| code-fold: show\nggplot(data = weather, mapping = aes(x = factor(month), y = temp, fill=factor(month))) +\n  geom_boxplot(show.legend = FALSE) +\n  labs(x = \"Month\", y = \"Temperature (Hourly)\",\n        title = \"Hourly temperatures from NYC in 2013 by month\")  +\n  scale_x_discrete(labels = c(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                              \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"))\n```\n\n# Barplots\n\nBarplots, or barcharts, are used to visualise the distributions of categorical variables. This essentially provides us with the frequencies of categories within a categorical variable. Let's take a look at the distribution of airline carriers within the `flights` data that flew out of New York City in 2013. We can do this by creating a table containing the number of flights from each airline carrier as follows:\n\n```{r barplots, echo = TRUE, eval = TRUE, warning = FALSE}\ncarrier.freq <- table(flights$carrier)\ncarrier.freq <- as.data.frame(carrier.freq)\ncolnames(carrier.freq) <- c(\"carrier\", \"number\")\n```\n\nNote, `ggplot` expects the data passed to it to be a data frame, which is why the above table is converted into a data frame. The names of the columns in our data frames have also been updated using the `colnames` function.\n\nYou can use two types of data sets to create barplots in `ggplot`\n\n1.  A data set with variable(s) representing the categories (e.g. the original `flights` data set)\n\n    ```{r}\n    #| eval: false \n    ggplot(flights, aes(y = carrier)) +     geom_bar()\n    ```\n\nwhere `geom_bar()` creates a barplot layer by counting the number of cases for each level of a categorical variable.\n\n2.  A data set with variables representing the categories and the counts of each category (e.g. the `carrier.freq` data set we just created)\n\n```{r}\n#| eval: false  \nggplot(data = carrier.freq, aes(x = carrier, y = number)) +   geom_col()\n```\n\nHere, `geom_col()` expects a data set that already contains the counts for each group. Adding proper labels to the barplot produces:\n\n```{r barplots10, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = \"Carriers who flew out of New York City in 2013.\"}\nggplot(data = carrier.freq, mapping = aes(x = carrier, y = number)) +\n  geom_col() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nNote, the names of the airlines relating to the carrier codes can be found by typing `airlines` into the R console.\n\nBarplots can also be used to compare two categorical variables. For instance, let's say we wanted to look at the number of flights that flew out of New York City in 2013 from each carrier and from each airport (LGA, JFK and EWR). To obtain a table of this information we simply add the flights origin to our previous table as follows:\n\n```{r barplots4, echo = TRUE, eval = TRUE, warning = FALSE}\ncarrier.origin <- table(flights$origin, flights$carrier)\ncarrier.origin <- as.data.frame(carrier.origin)\ncolnames(carrier.origin) <- c(\"origin\", \"carrier\", \"number\")\n```\n\nThe barplot for comparing two categorical variables is very similar in this case, where we simply pass the additional `fill` argument to the `aes` function. Including the `fill` argument lets `ggplot` plot know that we want to split the barplot according to an additional categorical variable, which is `origin` in this case. The barplot is then given by:\n\n```{r barplots11, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Stacked barplot of carriers who flew out of New York City in 2013.\"}\nggplot(data = carrier.origin, aes(x = carrier, y = number, fill = origin)) +\n  geom_col() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nAlternatively, we can use the original `flights` data set and specify `geom_bar()` as the new layer. Notice that we have also added the function `coord_flip()` to rotate the plot and achieve the same output as before.\n\n```{r}\nggplot(data = flights,\n       aes(y = carrier,fill=origin)) +\n  geom_bar()+\n  coord_flip() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nThis is what is referred to as a *Stacked barplot* since the bars for each `origin` are simply stacked on top of one another for each of the carriers. This provides us with a visually nice barplot to present our carrier information by airport of origin. However, there are also alternative barplots to the stacked barplot. One alternative to a stacked barplot is the **side-by-side** (or **dodged**) **barplot**, which, as suggested by its name, places the bars next to each other instead of on top of one another. This can be produced as follows:\n\n```{r barplots12, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Dodged barplot of carriers who flew out of New York City in 2013.\"}\nggplot(data = flights,\n       aes(y = carrier,fill=origin)) +\n  geom_bar(position = 'dodge')+\n  coord_flip() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nThis is done by passing to the either the `geom_bar` or the `geom_col` function the `position` of the barplots, which in this case is `dodged`. Before moving on, consider the following two questions:\n\n-   What could be considered a positive of using a side-by-side barplot as opposed to a stacked barplot?\n-   What could be a disadvantage of using a side-by-side barplot?\n\nLastly, let's take a look at what is referred to as a **faceted barplot**. They provide an easier way to compare the carrier distributions by origin, and can be obtained as follows:\n\n```{r barplots13, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Faceted barplot of carriers who flew out of New York City in 2013.\"}\n\n\nggplot(data = flights,\n       aes(y = carrier,fill=origin)) +\n  geom_bar()+\n  coord_flip()+\n  facet_wrap(~ origin, ncol = 1) +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nHere we include the `facet_wrap` function, where we want separate barplots by `origin`, and hence we use `~ origin`. We also choose to have them plotted in one column via `ncol = 1`. This makes it easier to compare their distributions now that they are not stacked on top or beside one another.\n\nBefore moving on to the next section, consider the following questions:\n\n-   What is the difference between histograms and barplots?\n\n-   Why can't we use histograms to visualise categorical variables?\n\n## Percentage/proportion barplots\n\nComparing raw frequencies between categories can sometimes be a bit misleading in the sense that raw counts do not consider the total number events (e.g. comparing the number of flights departing from certain origin between two carries should consider the total number of flights from all the origins for those given carries). Instead of plotting the raw frequencies, we can plot the proportions or the percentages per category.Â \n\nBy default, `ggplot` maps at the beginning, using the layer data provided by the user. Alternatively, we can tell `ggplot` to map after a layer `stat()` has applied a defined statistical transformation using the `after_stat` function. The examples we have seen so far have used the default setting `stat = \"identity\"`. Now we will use a `prop` statistic component to compute the proportion of the number of cases for each level of a categorical variable out of the total counts. To do this we will load the `ggstats` library which adds new statistics, geometries and positions to ggplot objects.\n\n```{r}\n#| echo: true \n#| message: false \n#| fig-align: center \n#| warning: false\n\nlibrary(ggstats) \nggplot(data = flights, \n       aes(x = carrier, y = after_stat(prop), fill = origin)) +\n  geom_bar(stat = \"prop\")    \n```\n\nNotice that these are the proportions out of the total flights. What if we want the proportions by carrier?\n\nThe `prop` statistic imported from the `ggstats` library allow us to compute custom proportions according to the `by` aesthetic argument (which should be declared as a **factor**). For example, if we want to compute the proportions separaely for each value of the carrier, we would write:\n\n```{r}\n#| fig-align: center \n\nggplot(data = flights,\n       aes(x = carrier, \n           y = after_stat(prop), \n           fill = origin, \n           by=factor(carrier))) +  \n  geom_bar(stat = \"prop\") + \n  geom_text(stat = \"prop\",\n            position = position_fill(vjust=0.5))+\n  labs(x = \"Carrier\", y = \"Proportion of flights per carrier\") \n```\n\nNotice that we added the `geom_text` layer to include the percentages per carrier.\n\n# Linegraphs\n\nLinegraphs are typically used when looking at *time series* data, that is, when we have information on how a variable changes over time. Hence, there is a natural ordering to the data when observing how something changes over time, and therefore, linegraphs should be avoided if there is no sequential ordering of a variable. Let's again look at the hourly temperature data, but this time only for Newark International Airport in January. This can be done by first subsetting the data as follows:\n\n```{r linegraph, echo = TRUE, eval = TRUE, warning = FALSE}\nNewark.Jan <- weather[weather$origin == \"EWR\" & weather$month == 1, ]\n```\n\nTo produce linegraphs using `ggplot` we use the `geom_line` function. Hence, our linegraph for the hourly temperatures at Newark International Airport in January 2013 can be created as follows:\n\n```{r linegraph3, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Hourly temperature at Newark Airport in January 2013.\"}\nggplot(data = Newark.Jan, mapping = aes(x = time_hour, y = temp)) +\n  geom_line() +\n    labs(x = \"Time (Hours)\", y = \"Temperature\",\n        title = \"Hourly Temperature at Newark Airport in January 2013\") \n```\n\nBefore moving on to the week's tasks, consider the following:\n\n-   In the code for the linegraph above, why has `time_hour` been plotted on the x-axis and not `hour`?\n-   Why should linegraphs be avoided when there is no sequential ordering of the data?\n-   Why are linegraphs used when time is the explanatory variable?\n-   Describe the trend in hourly temperature at Newark International Airport in January 2013.\n","srcMarkdownNoYaml":"\n\n# Getting started\n\nThis week we will demonstrate various techniques for visualising data in R using `ggplot2`. This will also include the correct interpretation and understanding of the different plotting techniques.\n\n::: callout-note\nA lot of the content within this course is based on the open-source book [An Introduction to Statistical and Data Science via R](https://moderndive.com/index.html) and thus is a useful source for additional examples and questions.\n:::\n\nFirst, start by opening **RStudio** by going to `Desktop -> Maths-Stats -> RStudio`. Once RStudio has opened create a new R script by going to `File -> New File -> R Script`. Next go to `File -> Save As...` and save the script into your personal drive, either `M:` or `K:` (do not save it to the `H:` drive). We shall now load into R all of the libraries we will need for this session. This can be done by typing the following into your R script:\n\n```{r}\n#| message: false\n#| warning: false\nlibrary(ggplot2)\nlibrary(nycflights13)\n```\n\nThe libraries can be loaded into R by highlighting them in your script and then clicking on the `Run` button located in the top right of the script window. The first library `ggplot2` allows us to use functions within that package in order to create nicer data visualisations. The second library `nycflights13` contains data on flights from New York City in 2013 that we shall be examining.\n\n# Viewing the data\n\nBefore visualising any data set, we first need to know its contents. For example, the contents of the `flights` data within the `nycflights13` library can be observed using the following command:\n\n```{r}\nhead(flights, n = 3)\n```\n\nThis prints to the R console the first `n = 3` rows of the `flights` data set, displaying each of the variables within said data set. We now know the data set contains `r ncol(flights)` variables, as well as their names. A quick check on the size of a data set can be obtained using:\n\n```{r}\ndim(flights)\n```\n\nwhich displays the dimensions of the data set. Thus, here we have `r nrow(flights)` rows and `r ncol(flights)` columns worth of data.\n\nTo reduce the amount of data we will be working with and make things a little easier, let's only look at *Alaska Airlines* flights leaving from New York City in 2013. This can be done by subsetting the data in such a way that we only observe flights from Alaska Airlines (carrier code AS), as follows:\n\n```{r alaska, echo = TRUE, eval = TRUE}\nAlaska <- flights[flights$carrier == \"AS\", ]\n```\n\nThis essentially picks out all of the rows within the `flights` data set for which the carrier code is `AS` and discards the rest, thus creating a new data set entitled `Alaska`. Next week we will look at more sophisticated ways of manipulating data sets. Now, let us go on to look at different visualisations of our `Alaska` data set using `ggplot2`, starting with **scatterplots**.\n\n# Scatterplots\n\nThe first data visualisation technique we introduce is the **Scatterplot** (or bivariate plot), which allows for two variables to be plotted against one another, with one plotted on the x-axis, and the other on the y-axis. This allows us to examine if there is any relationship between the two variables, such as positive or negative correlation, and whether the relationship appears linear or not. Let's say we wanted to observe the relationship between departure and arrival delays. We can do that in R using the `ggplot` function. First, we can set up the plotting region for our scatterplot of departure against arrival delays as follows:\n\n```{r ggplot, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Plot with no layers.\", out.width = '50%',message=FALSE,warning=FALSE}\nggplot(data = Alaska, \n       mapping = aes(x = dep_delay, y = arr_delay)) \n```\n\nHere, we have set up our plotting region by giving to the `ggplot` function:\n\n1.  The data `Alaska` by setting `data = Alaska`.\n2.  The mapping of the coordinates for the axes using `aes(x = dep_delay, y = arr_delay)`, where `aes()` relates to the plots aesthetics. That is,\n    -   `dep_delay` maps to the `x` coordinate; and\n    -   `arr_delay` maps to the `y` coordinate.\n\nIn order to include the points on the scatterplot we now need to add an additional layer using the `+` command. A layer combines data, aesthetic mapping, a geom (geometric object), a stat (statistical transformation), and a position adjustment:\n\n```{r}\n#| eval: false\n#| code-fold: show\n  layer(\n  mapping = NULL, \n  data = NULL,\n  geom = \"point\", \n  stat = \"identity\",\n  position = \"identity\"\n)\n```\n\nThe points are then added by creating a points layer:\n\n```{r ggplot2, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Relationship between arrival and departure delays.\"}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_point()\n```\n\nwhere `geom_point` specifies that the geometric objects to add to our plotting region are points.\n\nWhen adding layers using `ggplot` it should be noted that:\n\n-   the `+` command should come at the end of lines, otherwise R will produce an error.\n-   when adding additional layers it is a good idea to take a new line after each `+` command. This is so your code will be nice and clear with each layer given its own line of code. This is handy for code debugging.\n\nWe can change the axes labels and include a title on our plot by adding another layer as follows:\n\n```{r ggplot3, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Relationship between arrival and departure delays with nice labels.\", out.width = '65%'}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_point() +\n  labs(x = \"Departure delay (minutes)\", y = \"Arrival delay (minutes)\",\n       title = \"Alaska Airlines flights leaving NYC in 2013\") \n```\n\n## Over-plotting\n\nFrom our scatterplot it is clear to see that the vast majority of the points lie close to zero for both departure and arrival delays. This can make it difficult at times to observe what is going on. This is due to so many points being plotted very close to each other, and often plotted over one another in such a way that it is impossible to count how many points are actually plotted. This is referred to as **over-plotting**. Using `ggplot`, there are two ways we can address this problem:\n\n1.  adjust the transparency of the plotted points using the `alpha` argument.\n2.  jitter the points using the `geom_jitter` function.\n\n### Adjust transparency\n\nWe shall first alter the transparency of the points and see if this improves the situation. This is done as follows:\n\n```{r ggplot4, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Relationship between arrival and departure delays with alpha = 0.2.\"}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_point(alpha = 0.2) +\n  labs(x = \"Departure delay (minutes)\", y = \"Arrival delay (minutes)\",\n       title = \"Alaska Airlines flights leaving NYC in 2013\") \n```\n\nThe `alpha` command ranges between 0 and 1, where 0 relates to 100% transparency, while 1 (default) sets the points to be 100% opaque. By changing the transparency levels of the points we can observe clusters of points that are close to one another as they will be darker than areas of the plot with fewer points clustered together.\n\n### **Jittering**\n\nThe idea behind jittering is that each point is randomly moved, or nudged, slightly from its original position in such a way that clusters of points with the same coordinates can be observed, instead of being plotted on top of one another. To understand this, let's create a small data set consisting purely of zeros, such that:\n\n```{r jitter example, echo = TRUE, eval = TRUE}\njitter.example <- matrix(0, nrow = 10, ncol = 2)\n```\n\nThis basically creates a `r nrow(jitter.example)` by `r ncol(jitter.example)` matrix of zeros. You can look at it in the console by simply typing:\n\n```{r jitter example2, echo = TRUE, eval = FALSE}\njitter.example\n```\n\nNow, `ggplot` only works with data frames and not matrices, so we need to convert `jitter.example` into a data frame. This can be done using:\n\n```{r jitter example3, echo = TRUE, eval = TRUE}\njitter.example <- as.data.frame(jitter.example)\n```\n\nThere are functions within R that can be used to determine whether an object is a matrix or a data frame. See\n\n```{r is examples, echo = TRUE, eval = FALSE}\n?is.matrix\n?is.data.frame\n```\n\nNow, let's plot our toy example:\n\n```{r jitter example4, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Jitter example data scatterplot.\", out.width = '50%'}\nggplot(data = jitter.example, mapping = aes(x = V1, y = V2)) + \n  geom_point()\n```\n\nNote that since changing `jitter.example` into a data frame, the columns have been given the default variable names `V1` and `V2`. From the plot, if you had never seen our toy example before you would think only a single value was plotted due to them all being zero. If we shift each of the points slightly using jittering we will be able to see them more clearly:\n\n```{r jitter example5, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Jittered scatterplot of jitter example data.\", out.width = '50%'}\nggplot(data = jitter.example, mapping = aes(x = V1, y = V2)) + \n  geom_jitter(width = 0.1, height = 0.1)\n```\n\nNote that `geom_jitter` has replaced `geom_point`. Now we can clearly see all 10 observations plotted. The amount of horizontal and vertical jittering of the points is controlled by the `width` and `height` arguments within `geom_jitter`.\n\nNow that we understand the idea behind jittering, let's produce a jittered scatterplot of the `Alaska` data:\n\n```{r ggplot5, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Jittered scatterplot of arrival and departure delays.\"}\nggplot(data = Alaska, mapping = aes(x = dep_delay, y = arr_delay)) + \n  geom_jitter(width = 30, height = 30) +\n  labs(x = \"Departure delay (minutes)\", y = \"Arrival delay (minutes)\",\n       title = \"Alaska Airlines flights leaving NYC in 2013\") \n```\n\nNow we can see more of the points plotted within the cluster of points around (0,0). However, since this cluster is so large, it can be argued that jittering has not helped much here. Also, it is important to add enough jitter in order to separate the overlapping of points, however, not so much that we lose any pattern observed within the points. It should also be noted that jittering does not change the actual values of the points within the data set, it is merely used to help with visualising the data.\n\n# Histograms\n\nHistograms allow us to look at the *statistical distribution* of a variable. They show us how many values of a variable fall within specified *bins*. These bins give ranges of values for which the variable lies. The bins can be altered, that is, by changing their width, or by increasing the number of bins, such that we see the distribution at a higher resolution.\n\nHere, let's take a look at the `weather` data set that is within the `nycflights13` library. This data set contains hourly weather data from three airports (LGA, JFK and EWR) in New York City in 2013. We can look at its contents via:\n\n```{r weather, echo = TRUE, eval = TRUE, warning = FALSE}\nhead(weather, n = 3)\n```\n\nTo create a histogram using `ggplot` we use the `geom_histogram` command, or layer, instead of `geom_point` as with scatterplots. We can create a histogram of the hourly temperature data in NYC in 2013 using `ggplot` as follows:\n\n```{r hist6, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013.\", out.width = '51%'}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram()\n```\n\nHere, `ggplot` tells us that it used 30 bins when creating the histogram. We can adjust the bins in `ggplot` using two different approaches. Either by adjusting the\n\n-   number of bins using the `bins` argument; or\n-   the width of the bins using the `binwidth` argument.\n\nLet's first start by specifying the number of bins as follows:\n\n```{r hist7, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013 (with 60 bins).\", out.width = '51%'}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(bins = 60, color = \"white\")\n```\n\nNote, we also specified the outline colour of the bins to make it easier to differentiate between them. The colour of the bins themselves can be changed by including the `fill` argument. The colour options available can be found by typing the following into the R console:\n\n```{r hist8, echo = TRUE, eval = FALSE}\ncolors()\n```\n\nInstead of specifying the number of bins, we can specify their width using `binwidth` as follows:\n\n```{r hist9, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013 (using binwidth).\"}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(binwidth = 5, color = \"white\")\n```\n\nFinally, we can give the histogram a title and clean up the labels to make them more informative.\n\n**Try recreating the following histogram by setting `bins = 60` and `fill = 'skyblue'`**\n\n```{r hist10, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = \"Histogram of hourly temperature recordings from NYC in 2013 with updated labels.\"}\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(bins = 60, color = \"white\", fill = \"skyblue\") +\n    labs(x = \"Temperature (Hourly)\",\n          title = \"Hourly temperatures from NYC in 2013\") \n```\n\n`r hide(\"I need a hint\")`\n\nSee the documentation for `geom_histogram()` (`?geom_histogram`)\n\n`r unhide()`\n\n<!-- note: you could also just set webex.hide to TRUE -->\n\n```{r, echo = TRUE, eval = FALSE}\n#| webex.hide: \"Click here to see the solution\"\n#| code-fold: show\n\nggplot(data = weather, mapping = aes(x = temp)) +\n  geom_histogram(bins = 60, color = \"white\", fill = \"skyblue\") +\n    labs(x = \"Temperature (Hourly)\",\n          title = \"Hourly temperatures from NYC in 2013\") \n```\n\n# Boxplots\n\nAnother way to look at the distribution of a variable is using a **boxplot**. A boxplot makes use of the standard *five-number summary*, that is\n\n-   the minimum value;\n-   the first quartile or 25th percentile;\n-   the median (or 2nd quartile / 50th percentile);\n-   the third quartile or 75th percentile;\n-   and the maximum value.\n\nKeeping with the hourly temperature data, the five-number summary can be obtained in R using the following command:\n\n```{r summary, echo = TRUE, eval = TRUE, warning = FALSE}\nsummary(weather$temp)\n```\n\nThis provides us with the five-number summary, as well as the `mean` hourly temperature. There is one missing value in the hourly temperature data, which is represented in R by `NA`.\n\nThe boxplot of the hourly temperature data is plotted below.\n\n```{r boxplot, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = \"Boxplot of hourly temperature recordings from NYC in 2013.\"}\nboxplot(weather$temp, ylab = \"Hourly Temperature\",\n        main = \"Hourly temperatures from NYC in 2013\")\ntext(x= 1.35, y= summary(weather$temp)[1], labels= \"Minimum\")\ntext(x= 1.35, y= summary(weather$temp)[2], labels= \"1st quartile\")\ntext(x= 1.35, y= summary(weather$temp)[3], labels= \"Median\")\ntext(x= 1.35, y= summary(weather$temp)[5], labels= \"3rd quartile\")\ntext(x= 1.35, y= summary(weather$temp)[6], labels= \"Maximum\")\n```\n\nThe elements of the boxplot relating to the five-number summary have also been labelled. Other features of the boxplot are:\n\n-   the *interquartile range (IQR)*, that is, the height of the box (3rd - 1st quartiles), and is a measure of the spread of the middle 50% of values. Longer boxes are indicative of greater variability.\n-   The dashed lines are known as *whiskers* and represent values less than the 25th percentile, and greater than the 75th percentile, respectively. The longer the whiskers, the more variability there is outside of the middle 50%.\n\nBoxplots are useful visualisations when comparing the distribution of a numerical variable split across groups (or a *categorical variable*). For example, we could look at how the hourly temperature changes by month, where month is our categorical, or grouping, variable.\n\nTo create boxplots using `ggplot` we use the `geom_boxplot` function. If we want to look at boxplots of a variable separately for a categorical variable then we need to introduce the `factor` function. This converts a numerical variable into a categorical one, essentially creating labels or categories from the numeric values. For example, the `month` variable within the `weather` data set is a numerical variable taking on the values 1,$\\ldots$,12, for each month. However, it makes more sense to convert this into a categorical variable using the `factor` function, such that:\n\n```{r boxplot5, echo = TRUE, eval = FALSE}\nweather$month\n```\n\n```{r boxplot6, echo = FALSE, eval = TRUE}\nweather$month[1:10]\n```\n\nbecomes\n\n```{r boxplot7, echo = TRUE, eval = FALSE}\nfactor(weather$month)\n```\n\n```{r boxplot8, echo = FALSE, eval = TRUE}\nfactor(weather$month)[1:10]\n```\n\nwith levels, or categories, 1,$\\ldots$,12 for each month. Hence, the boxplots can be produced using `ggplot` as follows:\n\n```{r boxplot9, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Boxplots of hourly temperature recordings from NYC in 2013 by month.\"}\nggplot(data = weather, mapping = aes(x = factor(month), y = temp)) +\n  geom_boxplot(fill = \"steelblue\") +\n  labs(x = \"Month\", y = \"Temperature (Hourly)\",\n        title = \"Hourly temperatures from NYC in 2013 by month\")  +\n  scale_x_discrete(labels = c(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                              \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"))\n```\n\nNote, we have introduced a new function `scale_x_discrete`, which is used to rename the labels of the boxplots. This function is used as our categorical variables are discrete in nature. After splitting the hourly temperatures by month, we now see points extending beyond the whiskers of the boxplots. These are known as *outliers*, and may be thought of as unusually small or large values. However, the definition of an outlier here is somewhat arbitrary as they are defined by the length of the whiskers, which are no more than 1.5 x *IQR*.\n\n**Try modifying the boxplot above by having a different fill color for each month.**\n\n`r hide(\"I need a hint\")`\n\nUse the `fill` aesthetic to declare the variable you want to colour\n\n`r unhide()`\n\n```{r, echo = TRUE, eval = FALSE}\n#| webex.hide: \"Click here to see the solution\"\n#| code-fold: show\nggplot(data = weather, mapping = aes(x = factor(month), y = temp, fill=factor(month))) +\n  geom_boxplot(show.legend = FALSE) +\n  labs(x = \"Month\", y = \"Temperature (Hourly)\",\n        title = \"Hourly temperatures from NYC in 2013 by month\")  +\n  scale_x_discrete(labels = c(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                              \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"))\n```\n\n# Barplots\n\nBarplots, or barcharts, are used to visualise the distributions of categorical variables. This essentially provides us with the frequencies of categories within a categorical variable. Let's take a look at the distribution of airline carriers within the `flights` data that flew out of New York City in 2013. We can do this by creating a table containing the number of flights from each airline carrier as follows:\n\n```{r barplots, echo = TRUE, eval = TRUE, warning = FALSE}\ncarrier.freq <- table(flights$carrier)\ncarrier.freq <- as.data.frame(carrier.freq)\ncolnames(carrier.freq) <- c(\"carrier\", \"number\")\n```\n\nNote, `ggplot` expects the data passed to it to be a data frame, which is why the above table is converted into a data frame. The names of the columns in our data frames have also been updated using the `colnames` function.\n\nYou can use two types of data sets to create barplots in `ggplot`\n\n1.  A data set with variable(s) representing the categories (e.g. the original `flights` data set)\n\n    ```{r}\n    #| eval: false \n    ggplot(flights, aes(y = carrier)) +     geom_bar()\n    ```\n\nwhere `geom_bar()` creates a barplot layer by counting the number of cases for each level of a categorical variable.\n\n2.  A data set with variables representing the categories and the counts of each category (e.g. the `carrier.freq` data set we just created)\n\n```{r}\n#| eval: false  \nggplot(data = carrier.freq, aes(x = carrier, y = number)) +   geom_col()\n```\n\nHere, `geom_col()` expects a data set that already contains the counts for each group. Adding proper labels to the barplot produces:\n\n```{r barplots10, echo = FALSE, eval = TRUE, warning = FALSE, fig.cap = \"Carriers who flew out of New York City in 2013.\"}\nggplot(data = carrier.freq, mapping = aes(x = carrier, y = number)) +\n  geom_col() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nNote, the names of the airlines relating to the carrier codes can be found by typing `airlines` into the R console.\n\nBarplots can also be used to compare two categorical variables. For instance, let's say we wanted to look at the number of flights that flew out of New York City in 2013 from each carrier and from each airport (LGA, JFK and EWR). To obtain a table of this information we simply add the flights origin to our previous table as follows:\n\n```{r barplots4, echo = TRUE, eval = TRUE, warning = FALSE}\ncarrier.origin <- table(flights$origin, flights$carrier)\ncarrier.origin <- as.data.frame(carrier.origin)\ncolnames(carrier.origin) <- c(\"origin\", \"carrier\", \"number\")\n```\n\nThe barplot for comparing two categorical variables is very similar in this case, where we simply pass the additional `fill` argument to the `aes` function. Including the `fill` argument lets `ggplot` plot know that we want to split the barplot according to an additional categorical variable, which is `origin` in this case. The barplot is then given by:\n\n```{r barplots11, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Stacked barplot of carriers who flew out of New York City in 2013.\"}\nggplot(data = carrier.origin, aes(x = carrier, y = number, fill = origin)) +\n  geom_col() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nAlternatively, we can use the original `flights` data set and specify `geom_bar()` as the new layer. Notice that we have also added the function `coord_flip()` to rotate the plot and achieve the same output as before.\n\n```{r}\nggplot(data = flights,\n       aes(y = carrier,fill=origin)) +\n  geom_bar()+\n  coord_flip() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nThis is what is referred to as a *Stacked barplot* since the bars for each `origin` are simply stacked on top of one another for each of the carriers. This provides us with a visually nice barplot to present our carrier information by airport of origin. However, there are also alternative barplots to the stacked barplot. One alternative to a stacked barplot is the **side-by-side** (or **dodged**) **barplot**, which, as suggested by its name, places the bars next to each other instead of on top of one another. This can be produced as follows:\n\n```{r barplots12, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Dodged barplot of carriers who flew out of New York City in 2013.\"}\nggplot(data = flights,\n       aes(y = carrier,fill=origin)) +\n  geom_bar(position = 'dodge')+\n  coord_flip() +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nThis is done by passing to the either the `geom_bar` or the `geom_col` function the `position` of the barplots, which in this case is `dodged`. Before moving on, consider the following two questions:\n\n-   What could be considered a positive of using a side-by-side barplot as opposed to a stacked barplot?\n-   What could be a disadvantage of using a side-by-side barplot?\n\nLastly, let's take a look at what is referred to as a **faceted barplot**. They provide an easier way to compare the carrier distributions by origin, and can be obtained as follows:\n\n```{r barplots13, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Faceted barplot of carriers who flew out of New York City in 2013.\"}\n\n\nggplot(data = flights,\n       aes(y = carrier,fill=origin)) +\n  geom_bar()+\n  coord_flip()+\n  facet_wrap(~ origin, ncol = 1) +\n  labs(x = \"Carrier\", y = \"Count\",\n        title = \"Carriers who flew out of New York City in 2013\") \n```\n\nHere we include the `facet_wrap` function, where we want separate barplots by `origin`, and hence we use `~ origin`. We also choose to have them plotted in one column via `ncol = 1`. This makes it easier to compare their distributions now that they are not stacked on top or beside one another.\n\nBefore moving on to the next section, consider the following questions:\n\n-   What is the difference between histograms and barplots?\n\n-   Why can't we use histograms to visualise categorical variables?\n\n## Percentage/proportion barplots\n\nComparing raw frequencies between categories can sometimes be a bit misleading in the sense that raw counts do not consider the total number events (e.g. comparing the number of flights departing from certain origin between two carries should consider the total number of flights from all the origins for those given carries). Instead of plotting the raw frequencies, we can plot the proportions or the percentages per category.Â \n\nBy default, `ggplot` maps at the beginning, using the layer data provided by the user. Alternatively, we can tell `ggplot` to map after a layer `stat()` has applied a defined statistical transformation using the `after_stat` function. The examples we have seen so far have used the default setting `stat = \"identity\"`. Now we will use a `prop` statistic component to compute the proportion of the number of cases for each level of a categorical variable out of the total counts. To do this we will load the `ggstats` library which adds new statistics, geometries and positions to ggplot objects.\n\n```{r}\n#| echo: true \n#| message: false \n#| fig-align: center \n#| warning: false\n\nlibrary(ggstats) \nggplot(data = flights, \n       aes(x = carrier, y = after_stat(prop), fill = origin)) +\n  geom_bar(stat = \"prop\")    \n```\n\nNotice that these are the proportions out of the total flights. What if we want the proportions by carrier?\n\nThe `prop` statistic imported from the `ggstats` library allow us to compute custom proportions according to the `by` aesthetic argument (which should be declared as a **factor**). For example, if we want to compute the proportions separaely for each value of the carrier, we would write:\n\n```{r}\n#| fig-align: center \n\nggplot(data = flights,\n       aes(x = carrier, \n           y = after_stat(prop), \n           fill = origin, \n           by=factor(carrier))) +  \n  geom_bar(stat = \"prop\") + \n  geom_text(stat = \"prop\",\n            position = position_fill(vjust=0.5))+\n  labs(x = \"Carrier\", y = \"Proportion of flights per carrier\") \n```\n\nNotice that we added the `geom_text` layer to include the percentages per carrier.\n\n# Linegraphs\n\nLinegraphs are typically used when looking at *time series* data, that is, when we have information on how a variable changes over time. Hence, there is a natural ordering to the data when observing how something changes over time, and therefore, linegraphs should be avoided if there is no sequential ordering of a variable. Let's again look at the hourly temperature data, but this time only for Newark International Airport in January. This can be done by first subsetting the data as follows:\n\n```{r linegraph, echo = TRUE, eval = TRUE, warning = FALSE}\nNewark.Jan <- weather[weather$origin == \"EWR\" & weather$month == 1, ]\n```\n\nTo produce linegraphs using `ggplot` we use the `geom_line` function. Hence, our linegraph for the hourly temperatures at Newark International Airport in January 2013 can be created as follows:\n\n```{r linegraph3, echo = TRUE, eval = TRUE, warning = FALSE, fig.cap = \"Hourly temperature at Newark Airport in January 2013.\"}\nggplot(data = Newark.Jan, mapping = aes(x = time_hour, y = temp)) +\n  geom_line() +\n    labs(x = \"Time (Hours)\", y = \"Temperature\",\n        title = \"Hourly Temperature at Newark Airport in January 2013\") \n```\n\nBefore moving on to the week's tasks, consider the following:\n\n-   In the code for the linegraph above, why has `time_hour` been plotted on the x-axis and not `hour`?\n-   Why should linegraphs be avoided when there is no sequential ordering of the data?\n-   Why are linegraphs used when time is the explanatory variable?\n-   Describe the trend in hourly temperature at Newark International Airport in January 2013.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css","include/webex.css"],"toc":true,"include-after-body":["include/webex.js"],"number-sections":true,"output-file":"DA_Week1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"visual","theme":"cosmo","title":"Week 1: Visualising data using R","editor_options":{"chunk_output_type":"console"},"toc-location":"left","toc-title":"Contents"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"DA_Week1.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"block-headings":true,"editor":"visual","title":"Week 1: Visualising data using R","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html"]}