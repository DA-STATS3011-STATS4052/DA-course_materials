[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Week 7: Collaborative Programming 1",
    "section": "",
    "text": "Version control is used throughout industry and academia as a way of developing and sharing code. Some people tend to think of version control as simply being GitHub, but it’s important to be aware that version control is a much more general area and GitHub is just a useful way of hosting a version control system called Git. An alternative approach might be more appropriate for your project, thus we recommend thinking through the needs of your project before committing to one scheme, however Git/GitHub is often a good choice for version control, hence why we have created a course around it. GitHub, as a host for Git repositories, is widely used within both academia and industry.\nThere is an increasing requirement that graduates must have this skill and you may even start to see version control in some of your courses if you are a student. From an academic perspective, there is a drive for open-access code, data, and research. Releasing your code via GitHub can help others use your research, increasing its utility and driving the impact of your work.\n\nA Version Control System is a tool that helps keep track of code and software development projects as they change over time. The idea is to save snapshots of code at any given time, called versions, to allow developers to understand how the code was developed and if necessary revert (go back) to previous versions.\nWhen coding collaboratively researchers or developers can work on the same code base, keeping individual versions of the code separate from each other. These different sections are called branches, which you’ll learn about in this course, can later be combined by the system such that code that has stayed the same remains unchanged and changes made by each researcher or developer can be combined into one version."
  },
  {
    "objectID": "index.html#what-is-a-version-control-system",
    "href": "index.html#what-is-a-version-control-system",
    "title": "Week 7: Collaborative Programming 1",
    "section": "",
    "text": "A Version Control System is a tool that helps keep track of code and software development projects as they change over time. The idea is to save snapshots of code at any given time, called versions, to allow developers to understand how the code was developed and if necessary revert (go back) to previous versions.\nWhen coding collaboratively researchers or developers can work on the same code base, keeping individual versions of the code separate from each other. These different sections are called branches, which you’ll learn about in this course, can later be combined by the system such that code that has stayed the same remains unchanged and changes made by each researcher or developer can be combined into one version."
  },
  {
    "objectID": "index.html#separate-instructions-for-the-command-line-and-github-desktop",
    "href": "index.html#separate-instructions-for-the-command-line-and-github-desktop",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n2.1 Separate instructions for the command line and GitHub Desktop",
    "text": "2.1 Separate instructions for the command line and GitHub Desktop\nAs with any tool, there are multiple ways of interacting with it and individuals tend to choose the way that works best for them/their workflow. Two of the most common ways of interacting with git/version control is either through the command line using the ‘git’ command or through a graphical user interface (GUI).\nTo address both needs throughout this course, you can either work through the examples using the command line or GitHub Desktop - a popular GUI (or compare both) for using Git. When you see a section that has a border around it, you can select either ‘Command-line’ or ‘GitHub Desktop’ at the top, and this will change all sections on the page to your preferred program."
  },
  {
    "objectID": "index.html#installation-and-command-line-usage",
    "href": "index.html#installation-and-command-line-usage",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n2.2 Installation and command-line usage",
    "text": "2.2 Installation and command-line usage\nAs Git is primarily a developer tool, it may be a little harder to install than you are used to. Git is a command-line program, however, you can opt to install a graphical user interface (GUI) for Git such as GitHub Desktop and avoid having to open a command-line terminal at all if you don’t want to!\nIf you’re familiar with installing command-line tools, GitHub provides a short guide named Install Git that should get you up and running quickly.\nBelow are some additional tips for those needing a bit more guidance.\n\n2.2.1 For Mac users\nGit is a command-line tool that is usually already installed on Macs and can be accessed from the built-in terminal. The Terminal application can be found by navigating to the Applications/Utilities folder or searching for ‘Terminal’ in Spotlight.\n\n2.2.2 For Windows users\nThis Getting Started guide provides a bit more detail on which options to select during the installation process for the best experience.\nAfter clicking the “Download Git for Windows” button you will arrive at a GitHub Release page, with lots of variations to choose from.\nTo know which option is right for your system, first, you need to find out if your computer is 32-bit or 64-bit:\nGo to Start &gt; Settings &gt; System &gt; About. Check the bit version under Device specifications &gt; System type.\nThen choose the .exe file that matches your system:\n\nOnce installed, it can be accessed from the Git Bash terminal which comes included as part of the Git For Windows package. You can find Git Bash by opening the Start menu and typing ‘Git Bash’ into the search bar. However, if you plan on using a GUI for Git such as GitHub Desktop, you don’t need to open a terminal at all."
  },
  {
    "objectID": "index.html#set-your-git-name-and-email-address",
    "href": "index.html#set-your-git-name-and-email-address",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n5.1 Set your Git Name and Email address",
    "text": "5.1 Set your Git Name and Email address\nGit needs a name and email address to attach to your commit signature (a bit like an email signature). Let’s set this up now, and be sure to use the same email address that you use to sign into GitHub.\n\n\nCommand-line\nGitHub Desktop\n\n\n\n\nCodegit config --global user.name \"Your Name\"\n\ngit config --global user.email \"youremail@yourdomain.com\"\n\n\nOnce done, you can confirm that the information is set by running:\n\nCodegit config --list\n\n\nAnd should see output similar to this:\nuser.name=Your Name\nuser.email=youremail@yourdomain.com\n\n\nFrom the main menu, select GitHub Desktop &gt; Settings... . In the settings pane, select ‘Git’ from the sidebar:"
  },
  {
    "objectID": "index.html#process-outline",
    "href": "index.html#process-outline",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n8.1 Process Outline",
    "text": "8.1 Process Outline\nOne way to think about a Git/GitHub project is a folder on your local computer which is version controlled and potentially (also) on GitHub.\nTo set up this structure, the workflow we are going to look at next is creating a local project folder, adding a file, initialising Git, and then saving a copy to Github. It’s also a valid workflow to first create a GitHub repository, then ‘clone’ it to your computer (see Unit 3).\nAs part of this course, you can either follow the instructions for Command-line or GitHub Desktop. Simply choose the tab you want below and all sections will change to the desired format. For example, the outline of the workflow is different for the two options, as GitHub Desktop automates some of the tasks:\n\n\nCommand-line\nGitHub Desktop\n\n\n\n\nCreate a local repository\nCreate a new file\nAdd the file to the Git ‘stage’\nCommit the file\nCreate a new repository on GitHub\nConfigure our local repository to point to the new GitHub repository as a remote ‘origin’\nPush our commit(s) to sync them with the repository on GitHub.\n\n\n\n\nCreate a local repository\nCreate a file\nCommit the file\nPublish the repository on GitHub.\n\n\n\n\nFinally, we are going to look at how you update this file. This essentially follows the same process where we:\n\nUpdate the file (or add one)\nAdd the changes\nCommit the changes\nPush the changes"
  },
  {
    "objectID": "index.html#stage-the-file",
    "href": "index.html#stage-the-file",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n12.1 Stage the file",
    "text": "12.1 Stage the file\nAdding files to the stage is an intermediate step before committing to a version. We need to choose (stage) the files we want to add to our commit. Staging may seem an unnecessary step at this point, but later we will demonstrate how this can be a powerful tool.\nFor now, we will stage all changes, our only file poem.txt.\n\n\nCommand-line\nGitHub Desktop\n\n\n\nWe can stage the file using the add command:\n\nCodegit add poem.txt\n\n\nNote that there two options here: * git add &lt;path&gt;: Stage a specific directory or file * git add .: Stage all files (that are not listed in the .gitignore) in the entire repository.\nNow we’ve staged the file let’s have a look at the status again:\n\nCodegit status\n\n\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached &lt;file&gt;...\" to unstage)\nnew file:   poem.txt\nOur poem.txt file has been added to the stage! If we view the short version we can see A for “add”:\n\nCodegit status -s\n\n\nA  poem.txt\nThere is also a --verbose or -v flag. In this case, it also includes the “diff” of poem.txt (more information on what a “diff” is after this example):\n\nCodegit status --verbose\n\n\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached &lt;file&gt;...\" to unstage)\nnew file:   poem.txt\n\ndiff --git a/poem.txt b/poem.txt\nnew file mode 100644\nindex 0000000..12f4ac3\n--- /dev/null\n+++ b/poem.txt\n@@ -0,0 +1,16 @@\n+Now We Are Six by A. A. Milne\n+\n+When I was One,\n+I had just begun.\n+When I was Two,\n+I was nearly new.\n+When I was Three\n+I was hardly me.\n+When I was Four,\n+I was not much more.\n+When I was Five,\n+I was just alive.\n+But now I am Six,\n+I'm as clever as clever,\n+So I think I'll be six now for ever and ever.\n+\nWe can view this “diff” output on its own using the command in the next box.\n\n\n\nGitHub Desktop has automatically added our new file to the stage as you can see by the checked checkbox.\nThe green plus symbol here indicates this is a new file (or technically, it has not been added to Git yet).\nThis area displays the “diff” of poem.txt (more information on what a “diff” is after this example)."
  },
  {
    "objectID": "index.html#commit-the-first-version",
    "href": "index.html#commit-the-first-version",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n12.2 Commit the first version",
    "text": "12.2 Commit the first version\nOnce we have determined which files we want to stage, we can then commit the change(s). Importantly unlike (say) Dropbox, the changes in your project are not stored until you tell Git that they are ready to be stored i.e. in Git you ‘commit’ them.\nThe act of ‘committing’ in Git creates a ‘version’ (sometimes just called a ‘commit’). A version can be thought of as a snapshot of your whole project at that time. Once a commit has been made, it’s always possible to get back to this version. This simple concept can be extremely powerful for the evolution and maintenance of small to very large programming projects.\nEach version should be accompanied by a message describing the change made by the commit. This can be a skill in itself as you wish to tell your collaborators or your future self what changes have been made (we will discuss best practices in Unit 4).\n\n\nCommand-line\nGitHub Desktop\n\n\n\nNow let’s create our first commit!\n\nCodegit commit --message \"Create poem.txt\"\n\n\n[main (root-commit) acf18e1] Create poem.txt\n1 file changed, 16 insertions(+)\ncreate mode 100644 poem.txt\nIf you do not specify a message then Git will open up your text editor of choice (see unit 1) to add a message.\nExperienced users will use the shorthand -m instead of --message, i.e. git commit -m \"Create poem.txt\".\nGit status shows “working tree clean”, which means all changes detected in the directory have been committed to Git:\n\nCodegit status\n\n\nOn branch main\nnothing to commit, working tree clean\nLet’s have our first look at the log:\n\nCodegit log\n\n\ncommit acf18e19f0803fd405f7d1e196fbaf710066728d\nAuthor: David McArthur &lt;david.mcarthur.2@glasgow.ac.uk&gt;\nDate:   Mon Aug 21 13:41:25 2023 +0100\n\nCreate poem.txt\nThere is a log of our first version! (Again this opens vim, and to exit press : followed by q).\n\n\nMake sure the file is staged making sure the checkbox poem.txt is ticked, add the message “Create poem.txt” to the summary, then click the “Commit to main” button:\n\nWe have created our first commit! GitHub Desktop now says we have “No local changes”, which means all changes detected in the directory have been committed to Git:\n\nWhere did our commit go? By clicking on the “History” tab, we can see our first commit:"
  },
  {
    "objectID": "index.html#create-a-new-repository-on-github",
    "href": "index.html#create-a-new-repository-on-github",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n13.1 Create a new repository on GitHub",
    "text": "13.1 Create a new repository on GitHub\nUp to this point, we have been using Git locally. Next, let’s learn how to put a copy of our project on GitHub to share it with others or just make a backup for ourselves.\n\n\n\n\n\n\nPrivate or Public Repository\n\n\n\nWhen creating a GitHub repository, you will need to decide if it will be private or public. Private will mean the code is only available to yourself and other contributors, but public will mean that anyone will be able to see your code. The purpose and stage of your project will determine which of these makes the most sense.\nThe decision is ultimately a pragmatic one, and can strongly depend on your particular circumstances, for example, you may wish to develop a new open-source software library in a public repository to encourage interest and contributions from others earlier, or you may wish to keep it private either for your own use only or until it is ready to be shared. Approaches to this can also vary, in some parts of Academia it is common to having a public repository on active research projects, in others a repository is made public once the project has finished.\nImportant: Be careful not to put anything sensitive on a public repository as it will be accessible to all, although it is probably not to put it on GitHub either way.\n\n\n\n\nCommand-line\nGit-Desktop\n\n\n\nTo be able to add our content to a GitHub page (remote repository), you will firstly need to create a repository. GitHub Desktop does this for you, but for the command-line, we need to do it ourselves. You can do this by following the Create a repo quickstart guide to create a new repository for our example. Here it is named “tutorial1” but you can name it whatever you like.\nThe Git command for syncing local commits with GitHub is push. Let’s try it now:\n\nCodegit push\n\n\nfatal: No configured push destination.\nEither specify the URL from the command-line or configure a remote repository using\n\n    git remote add &lt;name&gt; &lt;url&gt;\n\nand then push using the remote name\n\n    git push &lt;name&gt;\nGit is telling us we still need to configure our local repository to use our new GitHub repository as a remote (a remote is a copy of our repository stored in another location, in this case on GitHub). When we ask Git to list the configured remotes there is no output:\n\nCodegit remote\n\n\norigin\nSo let’s set that up now.\nOn GitHub, copy the URL of your empty repository:\n\nAnd paste it in the following command:\n\nCodegit remote add origin &lt;your-repository-url&gt;\n\n\nYou can check git remote again:\n\nCodegit remote\n\n\norigin\n\nCodegit remote --verbose\n\n\norigin  https://github.com/dmca-glasgow/tutorial1.git (fetch)\norigin  https://github.com/dmca-glasgow/tutorial1.git (push)\nWe can see that our GitHub repository is configured for both fetch and push commands.\nNow let’s try to push again:\n\nCodegit push\n\n\nfatal: The current branch main has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin main\n\nTo have this happen automatically for branches without a tracking\nupstream, see 'push.autoSetupRemote' in 'git help config'.\nGit is telling us it can’t sync our local commits to main because GitHub doesn’t know about the main branch yet. So let’s follow its instructions to tell GitHub about this branch:\n\nCodegit push --set-upstream origin main\n\n\nTo https://github.com/isammarques/tutorial1.git\n  * [new branch]      main -&gt; main\nbranch 'main' set up to track 'origin/main'.\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\n\nIn GitHub Desktop, click the “Publish repository” tab, give it a name, and click the “Publish Repository” button:\n\n\n\n\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\nWe can click on the commits icon:\n\nTo view our commit history:\n\nAnd we can click on the branches button to view our main branch:"
  },
  {
    "objectID": "index.html#rename-the-file",
    "href": "index.html#rename-the-file",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n14.1 Rename the file",
    "text": "14.1 Rename the file\nFirst, let’s rename our poem.txt file to poem.md (for Markdown).\nIn Git terms, renaming a file is considered deleting one file (poem.txt) and creating a new file (poem.md).\n\n\nCommand-line\nGitHub Desktop\n\n\n\nYou can see that poem.md currently has ‘untracked’ status as it has not been added to Git yet.\n\nCodegit status\n\n\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n(use \"git add/rm &lt;file&gt;...\" to update what will be committed)\n(use \"git restore &lt;file&gt;...\" to discard changes in working directory)\ndeleted:    poem.txt\n\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\npoem.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\nThe icon beside poem.md has a plus symbol for a new, untracked file, whereas the poem.txt file has a red minus symbol indicating it has been deleted.\n\n\n\n\nNext, let’s commit this change. It might seem counter-intuitive, but we need to stage and commit both files in this scenario because adding a file and deleting a file are both actions that need to be committed.\n\n\nCommand-line\nGitHub Desktop\n\n\n\nLet’s do that now:\n\nCodegit add poem.txt poem.md\n\n\ngit commit -m 'rename poem.txt to poem.md'\n[main edac35e] rename poem.txt to poem.md\n1 file changed, 0 insertions(+), 0 deletions(-)\nrename poem.txt =&gt; poem.md (100%)"
  },
  {
    "objectID": "index.html#gitignore",
    "href": "index.html#gitignore",
    "title": "Week 7: Collaborative Programming 1",
    "section": "\n15.1 .gitignore",
    "text": "15.1 .gitignore\nWhen we share our codebase using Git and GitHub, either with the public or with colleagues, we can choose to exclude certain files (e.g. tell Git/GitHub never to consider them) by making use of a .gitignore file. To be more precise, we are telling Git to ignore these files from our project folder by not adding them to any commit change list.\n.gitignore files use a simple syntax to make it easy to match files. The entries in this file can also follow a matching pattern.\n\n\n* is used as a wildcard match\n\n/ is used to ignore pathnames relative to the .gitignore file\n\n# is used to add comments to a .gitignore file\n\nFor example:\n# &lt;-- comments start with a hash sign\n# empty lines are ignored\n\n# ignore 'passwords.txt' at the root of your project:\n/passwords.txt\n\n# ignore 'passwords.txt' anywhere in your project:\npasswords.txt\n\n# ignore 'cache' folder  at the root of your project:\n/cache/\n\n# ignore all 'cache' folders:\ncache/\n\n# ignore all .log files inside a 'logs' folder:\nlogs/*.log\n\n# ignore all .html files inside the 'logs' folder including sub-folders:\nlogs/**/*.log\n\n# ignore all files with .log extension:\n**/*.log\nIf a file has already been committed to Git, ignoring it with .gitignore won’t remove it from the repository, only it’s changes from that point on. If you’d like to remove a file from Git, the simplest way is to follow these steps:\n\nMove the file out of your project folder\nGit will treat the file as deleted. Stage and commit this change.\nAdd the file path to .gitignore\nMove the file back into your project folder\nCheck the stage and confirm that Git is ignoring it\nCommit the updated .gitignore file\n\nHowever, while the file has been removed it is still present in your history in future sections."
  }
]