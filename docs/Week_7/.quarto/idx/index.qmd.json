{"title":"Week 4: Collaborative Coding 1","markdown":{"yaml":{"title":"Week 4: Collaborative Coding 1","engine":"knitr","format":{"pdf":{"latex-auto-install":true},"html":{"code-link":true,"code-fold":true,"code-tools":{"source":false,"toggle":true},"toc":true,"toc-location":"left","toc-title":"Contents","number-sections":true}},"editor":"visual","editor_options":{"chunk_output_type":"console"}},"headingText":"Using Git","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(error = TRUE) \n```\n\nThis week's material is based on the **Version Control Course** from the School of Mathematics and Statistics from the University of Glasgow. The content has been reduced to fit the class structure. At the end of Week 5, please provide some feedback on the materials on <https://uofg.qualtrics.com/jfe/form/SV_56jF2LNgmA6qrhY>.\n\n\nVersion control is used throughout industry and academia as a way of developing and sharing code. Some people tend to think of version control as simply being GitHub, but it's important to be aware that version control is a much more general area and GitHub is just a useful way of hosting a version control system called Git. An alternative approach might be more appropriate for your project, thus we recommend thinking through the needs of your project before committing to one scheme, however Git/GitHub is often a good choice for version control, hence why we have created a course around it. GitHub, as a host for Git repositories, is widely used within both academia and industry.\n\nThere is an **increasing requirement** that graduates must have this skill and you may even start to see version control in some of your courses if you are a student. From an academic perspective, there is a drive for open-access code, data, and research. Releasing your code via GitHub can help others use your research, increasing its utility and driving the impact of your work.\n\n## What is a version control system\n\nA Version Control System is a tool that helps keep track of code and software development projects as they change over time. The idea is to save snapshots of code at any given time, called **versions**, to allow developers to understand how the code was developed and if necessary revert (go back) to previous versions.\n\nWhen coding collaboratively researchers or developers can work on the same code base, keeping individual versions of the code separate from each other. These different sections are called **branches**, which you'll learn about in this course, can later be combined by the system such that code that has stayed the same remains unchanged and changes made by each researcher or developer can be combined into one version.\n\n# Up and running\n\nTo get up and running you will need to install Git and sign up for a GitHub account. In this section, we will describe how to install Git on Mac and Windows and how to link it with your GitHub account.\n\n## Separate instructions for the command line and GitHub Desktop\n\nAs with any tool, there are multiple ways of interacting with it and individuals tend to choose the way that works best for them/their workflow. Two of the most common ways of interacting with git/version control is either through the command line using the 'git' command or through a graphical user interface (GUI).\n\nTo address both needs throughout this course, you can either work through the examples using the command line or GitHub Desktop - a popular GUI (or compare both) for using Git. When you see a section that has a border around it, you can select either 'Command-line' or 'GitHub Desktop' at the top, and this will change all sections on the page to your preferred program.\n\n## Installation and command-line usage\n\nAs Git is primarily a developer tool, it may be a little harder to install than you are used to. Git is a command-line program, however, you can opt to install a graphical user interface (GUI) for Git such as GitHub Desktop and avoid having to open a command-line terminal at all if you don't want to!\n\nIf you're familiar with installing command-line tools, GitHub provides a short guide named Install Git that should get you up and running quickly.\n\nBelow are some additional tips for those needing a bit more guidance.\n\n### For Mac users\n\nGit is a command-line tool that is usually already installed on Macs and can be accessed from the built-in terminal. The Terminal application can be found by navigating to the `Applications/Utilities` folder or searching for 'Terminal' in Spotlight.\n\n### For Windows users\n\nThis Getting Started guide provides a bit more detail on which options to select during the installation process for the best experience.\n\nAfter clicking the \"Download Git for Windows\" button you will arrive at a GitHub Release page, with lots of variations to choose from.\n\nTo know which option is right for your system, first, you need to find out if your computer is 32-bit or 64-bit:\n\nGo to `Start > Settings > System > About`. Check the bit version under `Device specifications > System type`.\n\nThen choose the `.exe` file that matches your system:\n\n![](images/image1.png)\n\nOnce installed, it can be accessed from the Git Bash terminal which comes included as part of the Git For Windows package. You can find Git Bash by opening the Start menu and typing 'Git Bash' into the search bar. However, if you plan on using a GUI for Git such as GitHub Desktop, you don't need to open a terminal at all.\n\n# Sign up for GitHub\n\nIf you haven't done so already, now is a good time to sign up for a free GitHub account which you can do by going to github.com and providing some account information. Make sure to pick a sensible and easy to remember username as you may be using this account for a long time to come!\n\n![](images/image2.png)\n\n# GitHub Desktop GUI for Git\n\nThere are several applications available which allow you to use Git via a graphical user interface (GUI). We will cover one of the most popular ones, GitHub Desktop, provided by GitHub.\n\nIf you are comfortable using the Git command-line interface directly, it is not necessary to install GitHub Desktop. Otherwise, navigate to desktop.github.com and install the correct version for your computer (e.g., Windows or Mac):\n\n![](images/image3.png)\n\nOnce installed open GitHub Desktop and sign in with your GitHub account's username and password.\n\nOther popular GUIs include Sourcetree and GitKraken, but we won't cover these in the course. The article Best Git GUI Clients is a good starting place if you'd like to learn more about the strengths and weaknesses of different GUIs.\n\n# Configuration\n\n## Set your Git Name and Email address\n\nGit needs a name and email address to attach to your commit signature (a bit like an email signature). Let's set this up now, and be sure to use the same email address that you use to sign into GitHub.\n\n::: panel-tabset\n## Command-line\n\n```{bash eval=FALSE}\ngit config --global user.name \"Your Name\"\n\ngit config --global user.email \"youremail@yourdomain.com\"\n```\n\nOnce done, you can confirm that the information is set by running:\n\n```{bash eval=FALSE}\ngit config --list\n```\n\nAnd should see output similar to this:\n\n```         \nuser.name=Your Name\nuser.email=youremail@yourdomain.com\n```\n\n## GitHub Desktop\n\nFrom the main menu, select GitHub `Desktop > Settings...` . In the settings pane, select 'Git' from the sidebar:\n\n![](images/image4.png)\n:::\n\n# Connect to GitHub\n\nLet's configure Git to communicate securely with our GitHub account.\n\n::: panel-tabset\n## Command-line\n\nThe most common way to seamlessly and securely connect Git to GitHub is using SSH (Secure Shell Protocol). If you are unfamiliar with the concepts and workflow of SSH, be prepared to spend a little time learning how it works and setting it up. Thankfully GitHub has excellent documentation for Mac, Windows and Linux on this subject which is provided below.\n\nThe process is as follows:\n\n### Create an SSH keypair and add the private key to ssh-agent\n\nFirst, run a command which generates an SSH key pair--- a public key and a private key. When prompted, enter a passphrase of your choice. Next, add the private key and associated passphrase to ssh-agent.\n\nFull instructions can be found on GitHub for [generating a new SSH key and adding it to the ssh-agent](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent).\n\n### Add the public key to your account on GitHub\n\nFull instructions can be found on GitHub for [adding a new SSH key to your GitHub account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account).\n\n### Test the connection\n\nYou can test the connection by running the command:\n\n```{bash eval = FALSE}\n ssh -T git@github.com\n```\n\nFull instructions can be found on GitHub for [testing your SSH connection](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/testing-your-ssh-connection).\n\n## GitHub Desktop\n\nFrom the main menu, select GitHub `Desktop > Settings...`. In the settings pane, select 'Accounts' from the sidebar, and click the 'Sign In' button underneath 'GitHub.com':\n\n![](images/image5.png)\n:::\n\n# Set your preferred code editor\n\nLastly, As part of using Git/GitHub you often need to write short messages explaining the changes you have made, which are often useful when others (or indeed yourself a few months down the line) are looking at your project.\n\nThus it is useful to set the preferred application that you might want to use for this task.\n\n::: panel-tabset\n## Command-line\n\nWhen you create a Git commit, which you will do often, Git will ask you to write a message and open [Vim](https://www.vim.org) by default. Vim is a very powerful terminal-based code editor, with complicated commands which makes some tasks when editing text or code much easier. However, Vim has a (famously) steep learning curve, and it is out of scope for this course however there are some excellent resources online if you wish to learn more.\n\nIf you are not familiar with Vim you could swap to an alternative editor (see the next few sections), although this change will only affect certain operations (e.g. writing a commit message if you did not specify it on the command line), and for other operations you will need to basic Vim, which we will introduce when appropriate.\n\nIf you do decide to use Vim or alternatively accidentally start it, slightly infuriatingly, for those who have not worked with it before, it is not easy to close! Hint: press : then q.\n\n### Nano\n\nNano is a popular choice when changing Vim, as even if it is unfamiliar to you, it's still command-line-based, and much more intuitive as it has helpful instructions at the bottom of each screen.\n\n![An example of a Nano window](images/image6.png)\n\nTo change Git's editor to Nano use the following command:\n\n```{bash eval = FALSE}\ngit config --global core.editor \"nano\"\n```\n\n### Other editors\n\nMost code editors can be configured to open via the command line. The first step is to ensure your preferred editor can be opened this way, for example:\n\n-   [VSCode](https://code.visualstudio.com) can be opened with `code` after [running a script](https://stackoverflow.com/questions/29955500/code-not-working-in-command-line-for-visual-studio-code-on-osx-mac).\n\n-   [Sublime Text](https://www.sublimetext.com) can be opened with `subl` after [running a script](https://stackoverflow.com/questions/25152711/subl-command-not-working-command-not-found/25154529).\n\n-   [RStudio](https://rstudio.com/products/rstudio) can be opened with `rs` [after running a script](https://www.xiegerts.com/post/open-rstudio-from-terminal/).\n\nOnce this is tested and working for your preferred editor, you can tell Git to use this command. Some editors also require a --wait flag, or they will open a blank page. For example:\n\n```{bash eval = FALSE}\ngit config --global core.editor \"subl --wait\"\n```\n\n## GitHub Desktop\n\nFrom the main menu, select GitHub `Desktop > Settings...`. In the settings pane, select 'Integrations', then select your preferred code editor from the dropdown under 'External Editor':\n\n![](images/image7.png)\n:::\n\n# Basic workflow for a single user\n\nThis section aims to familiarise you with Git commands, and the Git ethos. If you are using Git and GitHub primarily as a backup and sharing tool, then this section is for you. You may find more technically accurate descriptions of these commands elsewhere online, but in this tutorial, we will aim to minimise jargon as much as possible to ease understanding, particularly for those of you without a Computing Science background.\n\nTo illustrate some of the concepts behind git and GitHub we will use a graphical approach using a Git visualisation library called gitgraph. This will allow us to give a graphical understanding of what git is doing, alongside showing how to do this with either the command line or GitHub Desktop. These visualisations will be very important when we explore branching.\n\n## Process Outline\n\nOne way to think about a Git/GitHub project is a folder on your local computer which is version controlled and potentially (also) on GitHub.\n\nTo set up this structure, the workflow we are going to look at next is creating a local project folder, adding a file, initialising Git, and then saving a copy to Github. It's also a valid workflow to first create a GitHub repository, then 'clone' it to your computer (see Unit 3).\n\nAs part of this course, you can either follow the instructions for Command-line or GitHub Desktop. Simply choose the tab you want below and all sections will change to the desired format. For example, the outline of the workflow is different for the two options, as GitHub Desktop automates some of the tasks:\n\n::: panel-tabset\n## Command-line\n\n1.  Create a local repository\n\n2.  Create a new file\n\n3.  Add the file to the Git 'stage'\n\n4.  Commit the file\n\n5.  Create a new repository on GitHub\n\n6.  Configure our local repository to point to the new GitHub repository as a remote 'origin'\n\n7.  Push our commit(s) to sync them with the repository on GitHub.\n\n## GitHub Desktop\n\n1.  Create a local repository\n\n2.  Create a file\n\n3.  Commit the file\n\n4.  Publish the repository on GitHub.\n:::\n\nFinally, we are going to look at how you update this file. This essentially follows the same process where we:\n\n1.  Update the file (or add one)\n\n2.  Add the changes\n\n3.  Commit the changes\n\n4.  Push the changes\n\n## Create a local Git repository\n\nFirst we need to create a local Git repository which will allow us to work through this tutorial. Ensure you have Git installed (see the 'Installation and command-line usage' section).\n\n::: panel-tabset\n## Command-line\n\nCreate an empty folder on your computer using `mkdir` and then change to that directory using `cd`:\n\n```{bash eval=FALSE}\nmkdir tutorial1\n```\n\nAlternatively as we will create several tutorials throughout this course you may wish to first create a folder to contain them and then create the folder for the first tutorial.\n\nThen run `git init` to initialise Git inside the folder:\n\n```{bash eval=FALSE}\ncd tutorial1\ngit init\n```\n\n```         \nInitialized empty Git repository in /Users/staff/Work/tutorial1/.git/\n```\n\nThe `git init` command turns a simple folder into a Git repository.\n\n## GitHub Desktop\n\nChoose `File > New Repository...` from the menu.\n\nIn the \"Create a New Repository\" form, name the repository \"tutorial1\", set the \"Local Path\" field to your preferred location and click the \"Create Repository\" button:\n\n![](images/image8.png)\n:::\n\nThat's it! You now have a local Git repository running in this folder. We will come back and learn more about the settings for the README, Git Ignore, and License later on in the course. We can now visualise our new git repository, however as we have not added anything to our git it is currently empty.\n\nGit has created a new folder inside your folder called `.git`. You may not be able to see this folder on a Mac or Windows operating system, as it is a convention for files and folders that start with a `.` to be hidden by default. However, it is important to know that the folder is there, as it holds information that is necessary for Git to function correctly. This folder should not be manually edited, instead, you should use Git commands which in turn update the information here. If you decide to move all your files to another folder for some reason, be careful to also move this .git folder if you want to keep using your Git repository!\n\nIn the Finder on MacOS you can show hidden files using the following keyboard shortcut:\n\n```{bash eval = FALSE}\nShift + Command + \".\"\n```\n\nIn File Explorer on Windows, select:\n\n```{bash eval = FALSE}\nView > Show > Hidden items.\n```\n\n## Create a file\n\nNow let's add a file. Of course, this would usually be code, configuration, or documentation files, but to keep this course somewhat generic and avoid distracting programming concepts, let's add a short poem in a plain text file `poem.txt` to the folder. You should use your preferred Code Editor to create the file, such as VSCode or RStudio. If using Word or other \"rich text\" editors ensure you choose the File Format \"Plain text (`.txt`)\" when saving the file.\n\nEnsure the file is saved. Git can only 'see' changes that are saved.\n\n::: callout-note\n## poem.txt\n\nNow We Are Six by A. A. Milne\n\nWhen I was One,\\\n\nI had just begun.\\\n\nWhen I was Two,\\\n\nI was nearly new.\\\n\nWhen I was Three\\\n\nI was hardly me.\\\n\nWhen I was Four,\\\n\nI was not much more.\\\n\nWhen I was Five,\\\n\nI was just alive.\\\n\nBut now I am Six,\\\n\nI'm as clever as clever,\\\n\nSo I think I'll be six now for ever and ever.\n:::\n\nEnsure the file is saved. Git can only 'see' changes that are saved.\n\n## Git status\n\n::: panel-tabset\n## Command-line\n\nLet's have our first look at the output of `git status`.`git status` tries to provide helpful information depending on your current situation.\n\nWhen using Git, you'll run git status so often that it will soon become muscle memory! The `git status` command only outputs status information and won't modify commits or changes in your local repository.\n\nNow we've created a file let's see what it outputs:\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\n\nNo commits yet\n\nUntracked files:\n(use \"git add <file>...\" to include in what will be committed)\npoem.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\n1.  We can see that Git knows we're on the main branch (we'll introduce branching concepts gradually as we progress through the course).\n\n2.  There have been no commits yet (more on this later in this unit).\n\n3.  Git knows our `poem.txt` file has been created but it is still \"untracked\" (a version has not been explicitly added to Git yet and therefore this file is not covered by version control)\n\nThe `--short` or `-s` flag removes all but the most relevant information:\n\n```{bash eval=FALSE}\ngit status -s\n```\n\n```         \n?? poem.txt\n```\n\nHere we can see the Git shortened syntax for \"untracked\" is ??.\n\n## GitHub Desktop\n\nLet's have a look at GitHub Desktop. As you work on your project GitHub Desktop will watch your files update when it detects changes:\n\n![](images/image9.png)\n\nHere we can see Git has found our new file! We have added some numbered purple circles to the screenshot above, let's go through those areas:\n\n1.  Here we can see that Git knows we're on the main branch (we'll introduce branching concepts gradually as we progress through the course).\n\n2.  If you click on the History tab, you'll see there have been no commits yet (more on this later in this unit).\n\n3.  The checkbox beside the filename is checked, which in Git terms, means the file has been \"staged\" for commit\n\n![](images/image9.png)\n:::\n\n## Adding our file to our project\n\n### Stage the file\n\nAdding files to the stage is an intermediate step before committing to a version. We need to choose (stage) the files we want to add to our commit. Staging may seem an unnecessary step at this point, but later we will demonstrate how this can be a powerful tool.\n\nFor now, we will stage all changes, our only file poem.txt.\n\n::: panel-tabset\n## Command-line\n\nWe can stage the file using the add command:\n\n```{bash eval=FALSE}\ngit add poem.txt\n```\n\nNote that there two options here: \\* `git add <path>`: Stage a specific directory or file \\* `git add .`: Stage all files (that are not listed in the .gitignore) in the entire repository.\n\nNow we've staged the file let's have a look at the status again:\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached <file>...\" to unstage)\nnew file:   poem.txt\n```\n\nOur `poem.txt` file has been added to the stage! If we view the short version we can see `A` for \"add\":\n\n```{bash eval = FALSE}\ngit status -s\n```\n\n```         \nA  poem.txt\n```\n\nThere is also a `--verbose` or `-v` flag. In this case, it also includes the \"diff\" of `poem.txt` (more information on what a \"diff\" is after this example):\n\n```{bash eval=FALSE}\ngit status --verbose\n```\n\n```         \nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached <file>...\" to unstage)\nnew file:   poem.txt\n\ndiff --git a/poem.txt b/poem.txt\nnew file mode 100644\nindex 0000000..12f4ac3\n--- /dev/null\n+++ b/poem.txt\n@@ -0,0 +1,16 @@\n+Now We Are Six by A. A. Milne\n+\n+When I was One,\n+I had just begun.\n+When I was Two,\n+I was nearly new.\n+When I was Three\n+I was hardly me.\n+When I was Four,\n+I was not much more.\n+When I was Five,\n+I was just alive.\n+But now I am Six,\n+I'm as clever as clever,\n+So I think I'll be six now for ever and ever.\n+\n```\n\nWe can view this \"diff\" output on its own using the command in the next box.\n\n## GitHub Desktop\n\n1.  GitHub Desktop has automatically added our new file to the stage as you can see by the checked checkbox.\n2.  The green plus symbol here indicates this is a new file (or technically, it has not been added to Git yet).\n3.  This area displays the \"diff\" of `poem.txt` (more information on what a \"diff\" is after this example).\n\n![](images/image10.png)\n:::\n\n### Commit the first version\n\nOnce we have determined which files we want to stage, we can then commit the change(s). Importantly unlike (say) Dropbox, the changes in your project are not stored until you tell Git that they are ready to be stored i.e. in Git you 'commit' them.\n\nThe act of 'committing' in Git creates a 'version' (sometimes just called a 'commit'). A version can be thought of as a snapshot of your whole project at that time. Once a commit has been made, it's always possible to get back to this version. This simple concept can be extremely powerful for the evolution and maintenance of small to very large programming projects.\n\nEach version should be accompanied by a message describing the change made by the commit. This can be a skill in itself as you wish to tell your collaborators or your future self what changes have been made (we will discuss best practices in Unit 4).\n\n::: panel-tabset\n## Command-line\n\nNow let's create our first commit!\n\n```{bash eval=FALSE}\ngit commit --message \"Create poem.txt\"\n```\n\n```         \n[main (root-commit) acf18e1] Create poem.txt\n1 file changed, 16 insertions(+)\ncreate mode 100644 poem.txt\n```\n\nIf you do not specify a message then Git will open up your text editor of choice (see unit 1) to add a message.\n\nExperienced users will use the shorthand `-m` instead of `--message`, i.e. `git commit -m \"Create poem.txt\"`.\n\nGit status shows \"working tree clean\", which means all changes detected in the directory have been committed to Git:\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\nnothing to commit, working tree clean\n```\n\nLet's have our first look at the log:\n\n```{bash eval=FALSE}\ngit log\n```\n\n```         \ncommit acf18e19f0803fd405f7d1e196fbaf710066728d\nAuthor: David McArthur <david.mcarthur.2@glasgow.ac.uk>\nDate:   Mon Aug 21 13:41:25 2023 +0100\n\nCreate poem.txt\n```\n\nThere is a log of our first version! (Again this opens vim, and to exit press `:` followed by `q`).\n\n## GitHub Desktop\n\nMake sure the file is staged making sure the checkbox `poem.txt` is ticked, add the message \"Create poem.txt\" to the summary, then click the \"Commit to main\" button:\n\n![](images/image11.png)\n\nWe have created our first commit! GitHub Desktop now says we have \"No local changes\", which means all changes detected in the directory have been committed to Git:\n\n![](images/image12.png)\n\nWhere did our commit go? By clicking on the \"History\" tab, we can see our first commit:\n\n![](images/image13.png)\n:::\n\n## Get our project onto GitHub\n\nYou have now created a Git repository on your local machine and added a file, however this is only available to people who use your computer. In this section we will demonstrate how to make this available to everyone via the GitHub website.\n\n### Create a new repository on GitHub\n\nUp to this point, we have been using Git locally. Next, let's learn how to put a copy of our project on GitHub to share it with others or just make a backup for ourselves.\n\n::: callout-caution\n### **Private or Public Repository**\n\nWhen creating a GitHub repository, you will need to decide if it will be private or public. Private will mean the code is only available to yourself and other contributors, but public will mean that anyone will be able to see your code. The purpose and stage of your project will determine which of these makes the most sense.\n\nThe decision is ultimately a pragmatic one, and can strongly depend on your particular circumstances, for example, you may wish to develop a new open-source software library in a public repository to encourage interest and contributions from others earlier, or you may wish to keep it private either for your own use only or until it is ready to be shared. Approaches to this can also vary, in some parts of Academia it is common to having a public repository on active research projects, in others a repository is made public once the project has finished.\n\n**Important:**Â Be careful not to put anything sensitive on a public repository as it will be accessible to all, although it is probably not to put it on GitHub either way.\n:::\n\n::: panel-tabset\n## Command-line\n\nTo be able to add our content to a GitHub page (remote repository), you will firstly need to create a repository. GitHub Desktop does this for you, but for the command-line, we need to do it ourselves. You can do this by following the Create a repo quickstart guide to create a new repository for our example. Here it is named \"tutorial1\" but you can name it whatever you like.\n\nThe Git command for syncing local commits with GitHub is push. Let's try it now:\n\n```{bash eval=FALSE}\ngit push\n```\n\n```         \nfatal: No configured push destination.\nEither specify the URL from the command-line or configure a remote repository using\n\n    git remote add <name> <url>\n\nand then push using the remote name\n\n    git push <name>\n```\n\nGit is telling us we still need to configure our local repository to use our new GitHub repository as a remote (a remote is a copy of our repository stored in another location, in this case on GitHub). When we ask Git to list the configured remotes there is no output:\n\n```{bash eval=FALSE}\ngit remote\n```\n\n```         \norigin\n```\n\nSo let's set that up now.\n\nOn GitHub, copy the URL of your empty repository:\n\n![](images/image14.png)\n\nAnd paste it in the following command:\n\n```{bash eval=FALSE}\ngit remote add origin <your-repository-url>\n```\n\nYou can check `git remote` again:\n\n```{bash eval=FALSE}\ngit remote\n```\n\n```         \norigin\n```\n\n```{bash eval=FALSE}\ngit remote --verbose\n```\n\n```         \norigin  https://github.com/dmca-glasgow/tutorial1.git (fetch)\norigin  https://github.com/dmca-glasgow/tutorial1.git (push)\n```\n\nWe can see that our GitHub repository is configured for both fetch and push commands.\n\nNow let's try to push again:\n\n```{bash eval = FALSE}\ngit push\n```\n\n```         \nfatal: The current branch main has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin main\n\nTo have this happen automatically for branches without a tracking\nupstream, see 'push.autoSetupRemote' in 'git help config'.\n```\n\nGit is telling us it can't sync our local commits to main because GitHub doesn't know about the main branch yet. So let's follow its instructions to tell GitHub about this branch:\n\n```{bash eval = FALSE}\ngit push --set-upstream origin main\n```\n\n```         \nTo https://github.com/dmca-glasgow/tutorial1.git\n  * [new branch]      main -> main\nbranch 'main' set up to track 'origin/main'.\n```\n\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\n## Git-Desktop\n\nIn GitHub Desktop, click the \"Publish repository\" tab, give it a name, and click the \"Publish Repository\" button:\n\n![](images/image15.png)\n:::\n\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\n![](images/image16.png)\n\nWe can click on the commits icon:\n\n![](images/image17.png)\n\nTo view our commit history:\n\n![](images/image18.png)\n\nAnd we can click on the branches button to view our main branch:\n\n![](images/image19.png)\n\n## Updating your repository\n\nNow that we have a local Git repository that is linked to GitHub, let's briefly explore the process of updating our project.\n\n### Rename the file\n\nFirst, let's rename our `poem.txt` file to `poem.md` (for Markdown).\n\nIn Git terms, renaming a file is considered deleting one file (`poem.txt`) and creating a new file (poem.md).\n\n::: panel-tabset\n## Command-line\n\nYou can see that `poem.md` currently has 'untracked' status as it has not been added to Git yet.\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n(use \"git add/rm <file>...\" to update what will be committed)\n(use \"git restore <file>...\" to discard changes in working directory)\ndeleted:    poem.txt\n\nUntracked files:\n(use \"git add <file>...\" to include in what will be committed)\npoem.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n## GitHub Desktop\n\nThe icon beside `poem.md` has a plus symbol for a new, untracked file, whereas the `poem.txt` file has a red minus symbol indicating it has been deleted.\n\n![](images/image19_1.png)\n:::\n\nNext, let's commit this change. It might seem counter-intuitive, but we need to stage and commit both files in this scenario because adding a file and deleting a file are both actions that need to be committed.\n\n::: panel-tabset\n## Command-line\n\nLet's do that now:\n\n```{bash eval = FALSE}\ngit add poem.txt poem.md\n```\n\n```         \ngit commit -m 'rename poem.txt to poem.md'\n[main edac35e] rename poem.txt to poem.md\n1 file changed, 0 insertions(+), 0 deletions(-)\nrename poem.txt => poem.md (100%)\n```\n\n## GitHub Desktop\n\n![](images/image20.png)\n:::\n\n# Supplement: Special file conventions\n\nBoth Git and GitHub have special file conventions, where files with a particular name have special behaviours. Git uses the 'dotfile' convention (a `.` at the start of the name), whereas GitHub typically uses all-caps. The 'dotfile' convention is relatively common and as your operating system may know that they are used as configuration files they may not show up in our file manager.\n\nThe most important are listed below, but please see a [list of Git special files](https://stackoverflow.com/questions/12605576#12719247) and a [list of GitHub special files](https://github.com/joelparkerhenderson/github-special-files-and-paths) for more information.\n\n## .gitignore\n\nWhen we share our codebase using Git and GitHub, either with the public or with colleagues, we can choose to exclude certain files (e.g. tell Git/GitHub never to consider them) by making use of a `.gitignore` file. To be more precise, we are telling Git to ignore these files from our project folder by not adding them to any commit change list.\n\n```{=html}\n<!--`.gitignore` files use a simple syntax to make it easy to match files. The entries in this file can also follow a matching pattern.\n\n-   `*` is used as a wildcard match\n-   `/` is used to ignore pathnames relative to the .gitignore file\n-   `#` is used to add comments to a .gitignore file-->\n```\n\nFor example:\n\n```         \n# <-- comments start with a hash sign\n# empty lines are ignored\n\n# ignore 'passwords.txt' at the root of your project:\n/passwords.txt\n\n# ignore 'passwords.txt' anywhere in your project:\npasswords.txt\n\n# ignore 'cache' folder  at the root of your project:\n/cache/\n\n# ignore all 'cache' folders:\ncache/\n\n# ignore all .log files inside a 'logs' folder:\nlogs/*.log\n\n# ignore all .html files inside the 'logs' folder including sub-folders:\nlogs/**/*.log\n\n# ignore all files with .log extension:\n**/*.log\n```\n\nIf a file has already been committed to Git, ignoring it with .gitignore won't remove it from the repository, only it's changes from that point on. If you'd like to remove a file from Git, the simplest way is to follow these steps:\n\n1.  Move the file out of your project folder\n2.  Git will treat the file as deleted. Stage and commit this change.\n3.  Add the file path to .gitignore\n4.  Move the file back into your project folder\n5.  Check the stage and confirm that Git is ignoring it\n6.  Commit the updated .gitignore file\n\nHowever, while the file has been removed it is still present in your history in future sections.\n\n## .gitkeep\n\nA strange quirk of Git is that it is only concerned with files and not folders. Your project can be split into as many files and folders as you wish with no problems, but at some point, you may be confused that Git does not 'see' empty folders.\n\nAs a workaround, a common convention is to create an empty file inside the folder named `.gitkeep`, which you can commit, enabling you to store the (not really) empty folder in your repository.\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(error = TRUE) \n```\n\nThis week's material is based on the **Version Control Course** from the School of Mathematics and Statistics from the University of Glasgow. The content has been reduced to fit the class structure. At the end of Week 5, please provide some feedback on the materials on <https://uofg.qualtrics.com/jfe/form/SV_56jF2LNgmA6qrhY>.\n\n# Using Git\n\nVersion control is used throughout industry and academia as a way of developing and sharing code. Some people tend to think of version control as simply being GitHub, but it's important to be aware that version control is a much more general area and GitHub is just a useful way of hosting a version control system called Git. An alternative approach might be more appropriate for your project, thus we recommend thinking through the needs of your project before committing to one scheme, however Git/GitHub is often a good choice for version control, hence why we have created a course around it. GitHub, as a host for Git repositories, is widely used within both academia and industry.\n\nThere is an **increasing requirement** that graduates must have this skill and you may even start to see version control in some of your courses if you are a student. From an academic perspective, there is a drive for open-access code, data, and research. Releasing your code via GitHub can help others use your research, increasing its utility and driving the impact of your work.\n\n## What is a version control system\n\nA Version Control System is a tool that helps keep track of code and software development projects as they change over time. The idea is to save snapshots of code at any given time, called **versions**, to allow developers to understand how the code was developed and if necessary revert (go back) to previous versions.\n\nWhen coding collaboratively researchers or developers can work on the same code base, keeping individual versions of the code separate from each other. These different sections are called **branches**, which you'll learn about in this course, can later be combined by the system such that code that has stayed the same remains unchanged and changes made by each researcher or developer can be combined into one version.\n\n# Up and running\n\nTo get up and running you will need to install Git and sign up for a GitHub account. In this section, we will describe how to install Git on Mac and Windows and how to link it with your GitHub account.\n\n## Separate instructions for the command line and GitHub Desktop\n\nAs with any tool, there are multiple ways of interacting with it and individuals tend to choose the way that works best for them/their workflow. Two of the most common ways of interacting with git/version control is either through the command line using the 'git' command or through a graphical user interface (GUI).\n\nTo address both needs throughout this course, you can either work through the examples using the command line or GitHub Desktop - a popular GUI (or compare both) for using Git. When you see a section that has a border around it, you can select either 'Command-line' or 'GitHub Desktop' at the top, and this will change all sections on the page to your preferred program.\n\n## Installation and command-line usage\n\nAs Git is primarily a developer tool, it may be a little harder to install than you are used to. Git is a command-line program, however, you can opt to install a graphical user interface (GUI) for Git such as GitHub Desktop and avoid having to open a command-line terminal at all if you don't want to!\n\nIf you're familiar with installing command-line tools, GitHub provides a short guide named Install Git that should get you up and running quickly.\n\nBelow are some additional tips for those needing a bit more guidance.\n\n### For Mac users\n\nGit is a command-line tool that is usually already installed on Macs and can be accessed from the built-in terminal. The Terminal application can be found by navigating to the `Applications/Utilities` folder or searching for 'Terminal' in Spotlight.\n\n### For Windows users\n\nThis Getting Started guide provides a bit more detail on which options to select during the installation process for the best experience.\n\nAfter clicking the \"Download Git for Windows\" button you will arrive at a GitHub Release page, with lots of variations to choose from.\n\nTo know which option is right for your system, first, you need to find out if your computer is 32-bit or 64-bit:\n\nGo to `Start > Settings > System > About`. Check the bit version under `Device specifications > System type`.\n\nThen choose the `.exe` file that matches your system:\n\n![](images/image1.png)\n\nOnce installed, it can be accessed from the Git Bash terminal which comes included as part of the Git For Windows package. You can find Git Bash by opening the Start menu and typing 'Git Bash' into the search bar. However, if you plan on using a GUI for Git such as GitHub Desktop, you don't need to open a terminal at all.\n\n# Sign up for GitHub\n\nIf you haven't done so already, now is a good time to sign up for a free GitHub account which you can do by going to github.com and providing some account information. Make sure to pick a sensible and easy to remember username as you may be using this account for a long time to come!\n\n![](images/image2.png)\n\n# GitHub Desktop GUI for Git\n\nThere are several applications available which allow you to use Git via a graphical user interface (GUI). We will cover one of the most popular ones, GitHub Desktop, provided by GitHub.\n\nIf you are comfortable using the Git command-line interface directly, it is not necessary to install GitHub Desktop. Otherwise, navigate to desktop.github.com and install the correct version for your computer (e.g., Windows or Mac):\n\n![](images/image3.png)\n\nOnce installed open GitHub Desktop and sign in with your GitHub account's username and password.\n\nOther popular GUIs include Sourcetree and GitKraken, but we won't cover these in the course. The article Best Git GUI Clients is a good starting place if you'd like to learn more about the strengths and weaknesses of different GUIs.\n\n# Configuration\n\n## Set your Git Name and Email address\n\nGit needs a name and email address to attach to your commit signature (a bit like an email signature). Let's set this up now, and be sure to use the same email address that you use to sign into GitHub.\n\n::: panel-tabset\n## Command-line\n\n```{bash eval=FALSE}\ngit config --global user.name \"Your Name\"\n\ngit config --global user.email \"youremail@yourdomain.com\"\n```\n\nOnce done, you can confirm that the information is set by running:\n\n```{bash eval=FALSE}\ngit config --list\n```\n\nAnd should see output similar to this:\n\n```         \nuser.name=Your Name\nuser.email=youremail@yourdomain.com\n```\n\n## GitHub Desktop\n\nFrom the main menu, select GitHub `Desktop > Settings...` . In the settings pane, select 'Git' from the sidebar:\n\n![](images/image4.png)\n:::\n\n# Connect to GitHub\n\nLet's configure Git to communicate securely with our GitHub account.\n\n::: panel-tabset\n## Command-line\n\nThe most common way to seamlessly and securely connect Git to GitHub is using SSH (Secure Shell Protocol). If you are unfamiliar with the concepts and workflow of SSH, be prepared to spend a little time learning how it works and setting it up. Thankfully GitHub has excellent documentation for Mac, Windows and Linux on this subject which is provided below.\n\nThe process is as follows:\n\n### Create an SSH keypair and add the private key to ssh-agent\n\nFirst, run a command which generates an SSH key pair--- a public key and a private key. When prompted, enter a passphrase of your choice. Next, add the private key and associated passphrase to ssh-agent.\n\nFull instructions can be found on GitHub for [generating a new SSH key and adding it to the ssh-agent](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent).\n\n### Add the public key to your account on GitHub\n\nFull instructions can be found on GitHub for [adding a new SSH key to your GitHub account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account).\n\n### Test the connection\n\nYou can test the connection by running the command:\n\n```{bash eval = FALSE}\n ssh -T git@github.com\n```\n\nFull instructions can be found on GitHub for [testing your SSH connection](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/testing-your-ssh-connection).\n\n## GitHub Desktop\n\nFrom the main menu, select GitHub `Desktop > Settings...`. In the settings pane, select 'Accounts' from the sidebar, and click the 'Sign In' button underneath 'GitHub.com':\n\n![](images/image5.png)\n:::\n\n# Set your preferred code editor\n\nLastly, As part of using Git/GitHub you often need to write short messages explaining the changes you have made, which are often useful when others (or indeed yourself a few months down the line) are looking at your project.\n\nThus it is useful to set the preferred application that you might want to use for this task.\n\n::: panel-tabset\n## Command-line\n\nWhen you create a Git commit, which you will do often, Git will ask you to write a message and open [Vim](https://www.vim.org) by default. Vim is a very powerful terminal-based code editor, with complicated commands which makes some tasks when editing text or code much easier. However, Vim has a (famously) steep learning curve, and it is out of scope for this course however there are some excellent resources online if you wish to learn more.\n\nIf you are not familiar with Vim you could swap to an alternative editor (see the next few sections), although this change will only affect certain operations (e.g. writing a commit message if you did not specify it on the command line), and for other operations you will need to basic Vim, which we will introduce when appropriate.\n\nIf you do decide to use Vim or alternatively accidentally start it, slightly infuriatingly, for those who have not worked with it before, it is not easy to close! Hint: press : then q.\n\n### Nano\n\nNano is a popular choice when changing Vim, as even if it is unfamiliar to you, it's still command-line-based, and much more intuitive as it has helpful instructions at the bottom of each screen.\n\n![An example of a Nano window](images/image6.png)\n\nTo change Git's editor to Nano use the following command:\n\n```{bash eval = FALSE}\ngit config --global core.editor \"nano\"\n```\n\n### Other editors\n\nMost code editors can be configured to open via the command line. The first step is to ensure your preferred editor can be opened this way, for example:\n\n-   [VSCode](https://code.visualstudio.com) can be opened with `code` after [running a script](https://stackoverflow.com/questions/29955500/code-not-working-in-command-line-for-visual-studio-code-on-osx-mac).\n\n-   [Sublime Text](https://www.sublimetext.com) can be opened with `subl` after [running a script](https://stackoverflow.com/questions/25152711/subl-command-not-working-command-not-found/25154529).\n\n-   [RStudio](https://rstudio.com/products/rstudio) can be opened with `rs` [after running a script](https://www.xiegerts.com/post/open-rstudio-from-terminal/).\n\nOnce this is tested and working for your preferred editor, you can tell Git to use this command. Some editors also require a --wait flag, or they will open a blank page. For example:\n\n```{bash eval = FALSE}\ngit config --global core.editor \"subl --wait\"\n```\n\n## GitHub Desktop\n\nFrom the main menu, select GitHub `Desktop > Settings...`. In the settings pane, select 'Integrations', then select your preferred code editor from the dropdown under 'External Editor':\n\n![](images/image7.png)\n:::\n\n# Basic workflow for a single user\n\nThis section aims to familiarise you with Git commands, and the Git ethos. If you are using Git and GitHub primarily as a backup and sharing tool, then this section is for you. You may find more technically accurate descriptions of these commands elsewhere online, but in this tutorial, we will aim to minimise jargon as much as possible to ease understanding, particularly for those of you without a Computing Science background.\n\nTo illustrate some of the concepts behind git and GitHub we will use a graphical approach using a Git visualisation library called gitgraph. This will allow us to give a graphical understanding of what git is doing, alongside showing how to do this with either the command line or GitHub Desktop. These visualisations will be very important when we explore branching.\n\n## Process Outline\n\nOne way to think about a Git/GitHub project is a folder on your local computer which is version controlled and potentially (also) on GitHub.\n\nTo set up this structure, the workflow we are going to look at next is creating a local project folder, adding a file, initialising Git, and then saving a copy to Github. It's also a valid workflow to first create a GitHub repository, then 'clone' it to your computer (see Unit 3).\n\nAs part of this course, you can either follow the instructions for Command-line or GitHub Desktop. Simply choose the tab you want below and all sections will change to the desired format. For example, the outline of the workflow is different for the two options, as GitHub Desktop automates some of the tasks:\n\n::: panel-tabset\n## Command-line\n\n1.  Create a local repository\n\n2.  Create a new file\n\n3.  Add the file to the Git 'stage'\n\n4.  Commit the file\n\n5.  Create a new repository on GitHub\n\n6.  Configure our local repository to point to the new GitHub repository as a remote 'origin'\n\n7.  Push our commit(s) to sync them with the repository on GitHub.\n\n## GitHub Desktop\n\n1.  Create a local repository\n\n2.  Create a file\n\n3.  Commit the file\n\n4.  Publish the repository on GitHub.\n:::\n\nFinally, we are going to look at how you update this file. This essentially follows the same process where we:\n\n1.  Update the file (or add one)\n\n2.  Add the changes\n\n3.  Commit the changes\n\n4.  Push the changes\n\n## Create a local Git repository\n\nFirst we need to create a local Git repository which will allow us to work through this tutorial. Ensure you have Git installed (see the 'Installation and command-line usage' section).\n\n::: panel-tabset\n## Command-line\n\nCreate an empty folder on your computer using `mkdir` and then change to that directory using `cd`:\n\n```{bash eval=FALSE}\nmkdir tutorial1\n```\n\nAlternatively as we will create several tutorials throughout this course you may wish to first create a folder to contain them and then create the folder for the first tutorial.\n\nThen run `git init` to initialise Git inside the folder:\n\n```{bash eval=FALSE}\ncd tutorial1\ngit init\n```\n\n```         \nInitialized empty Git repository in /Users/staff/Work/tutorial1/.git/\n```\n\nThe `git init` command turns a simple folder into a Git repository.\n\n## GitHub Desktop\n\nChoose `File > New Repository...` from the menu.\n\nIn the \"Create a New Repository\" form, name the repository \"tutorial1\", set the \"Local Path\" field to your preferred location and click the \"Create Repository\" button:\n\n![](images/image8.png)\n:::\n\nThat's it! You now have a local Git repository running in this folder. We will come back and learn more about the settings for the README, Git Ignore, and License later on in the course. We can now visualise our new git repository, however as we have not added anything to our git it is currently empty.\n\nGit has created a new folder inside your folder called `.git`. You may not be able to see this folder on a Mac or Windows operating system, as it is a convention for files and folders that start with a `.` to be hidden by default. However, it is important to know that the folder is there, as it holds information that is necessary for Git to function correctly. This folder should not be manually edited, instead, you should use Git commands which in turn update the information here. If you decide to move all your files to another folder for some reason, be careful to also move this .git folder if you want to keep using your Git repository!\n\nIn the Finder on MacOS you can show hidden files using the following keyboard shortcut:\n\n```{bash eval = FALSE}\nShift + Command + \".\"\n```\n\nIn File Explorer on Windows, select:\n\n```{bash eval = FALSE}\nView > Show > Hidden items.\n```\n\n## Create a file\n\nNow let's add a file. Of course, this would usually be code, configuration, or documentation files, but to keep this course somewhat generic and avoid distracting programming concepts, let's add a short poem in a plain text file `poem.txt` to the folder. You should use your preferred Code Editor to create the file, such as VSCode or RStudio. If using Word or other \"rich text\" editors ensure you choose the File Format \"Plain text (`.txt`)\" when saving the file.\n\nEnsure the file is saved. Git can only 'see' changes that are saved.\n\n::: callout-note\n## poem.txt\n\nNow We Are Six by A. A. Milne\n\nWhen I was One,\\\n\nI had just begun.\\\n\nWhen I was Two,\\\n\nI was nearly new.\\\n\nWhen I was Three\\\n\nI was hardly me.\\\n\nWhen I was Four,\\\n\nI was not much more.\\\n\nWhen I was Five,\\\n\nI was just alive.\\\n\nBut now I am Six,\\\n\nI'm as clever as clever,\\\n\nSo I think I'll be six now for ever and ever.\n:::\n\nEnsure the file is saved. Git can only 'see' changes that are saved.\n\n## Git status\n\n::: panel-tabset\n## Command-line\n\nLet's have our first look at the output of `git status`.`git status` tries to provide helpful information depending on your current situation.\n\nWhen using Git, you'll run git status so often that it will soon become muscle memory! The `git status` command only outputs status information and won't modify commits or changes in your local repository.\n\nNow we've created a file let's see what it outputs:\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\n\nNo commits yet\n\nUntracked files:\n(use \"git add <file>...\" to include in what will be committed)\npoem.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\n1.  We can see that Git knows we're on the main branch (we'll introduce branching concepts gradually as we progress through the course).\n\n2.  There have been no commits yet (more on this later in this unit).\n\n3.  Git knows our `poem.txt` file has been created but it is still \"untracked\" (a version has not been explicitly added to Git yet and therefore this file is not covered by version control)\n\nThe `--short` or `-s` flag removes all but the most relevant information:\n\n```{bash eval=FALSE}\ngit status -s\n```\n\n```         \n?? poem.txt\n```\n\nHere we can see the Git shortened syntax for \"untracked\" is ??.\n\n## GitHub Desktop\n\nLet's have a look at GitHub Desktop. As you work on your project GitHub Desktop will watch your files update when it detects changes:\n\n![](images/image9.png)\n\nHere we can see Git has found our new file! We have added some numbered purple circles to the screenshot above, let's go through those areas:\n\n1.  Here we can see that Git knows we're on the main branch (we'll introduce branching concepts gradually as we progress through the course).\n\n2.  If you click on the History tab, you'll see there have been no commits yet (more on this later in this unit).\n\n3.  The checkbox beside the filename is checked, which in Git terms, means the file has been \"staged\" for commit\n\n![](images/image9.png)\n:::\n\n## Adding our file to our project\n\n### Stage the file\n\nAdding files to the stage is an intermediate step before committing to a version. We need to choose (stage) the files we want to add to our commit. Staging may seem an unnecessary step at this point, but later we will demonstrate how this can be a powerful tool.\n\nFor now, we will stage all changes, our only file poem.txt.\n\n::: panel-tabset\n## Command-line\n\nWe can stage the file using the add command:\n\n```{bash eval=FALSE}\ngit add poem.txt\n```\n\nNote that there two options here: \\* `git add <path>`: Stage a specific directory or file \\* `git add .`: Stage all files (that are not listed in the .gitignore) in the entire repository.\n\nNow we've staged the file let's have a look at the status again:\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached <file>...\" to unstage)\nnew file:   poem.txt\n```\n\nOur `poem.txt` file has been added to the stage! If we view the short version we can see `A` for \"add\":\n\n```{bash eval = FALSE}\ngit status -s\n```\n\n```         \nA  poem.txt\n```\n\nThere is also a `--verbose` or `-v` flag. In this case, it also includes the \"diff\" of `poem.txt` (more information on what a \"diff\" is after this example):\n\n```{bash eval=FALSE}\ngit status --verbose\n```\n\n```         \nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached <file>...\" to unstage)\nnew file:   poem.txt\n\ndiff --git a/poem.txt b/poem.txt\nnew file mode 100644\nindex 0000000..12f4ac3\n--- /dev/null\n+++ b/poem.txt\n@@ -0,0 +1,16 @@\n+Now We Are Six by A. A. Milne\n+\n+When I was One,\n+I had just begun.\n+When I was Two,\n+I was nearly new.\n+When I was Three\n+I was hardly me.\n+When I was Four,\n+I was not much more.\n+When I was Five,\n+I was just alive.\n+But now I am Six,\n+I'm as clever as clever,\n+So I think I'll be six now for ever and ever.\n+\n```\n\nWe can view this \"diff\" output on its own using the command in the next box.\n\n## GitHub Desktop\n\n1.  GitHub Desktop has automatically added our new file to the stage as you can see by the checked checkbox.\n2.  The green plus symbol here indicates this is a new file (or technically, it has not been added to Git yet).\n3.  This area displays the \"diff\" of `poem.txt` (more information on what a \"diff\" is after this example).\n\n![](images/image10.png)\n:::\n\n### Commit the first version\n\nOnce we have determined which files we want to stage, we can then commit the change(s). Importantly unlike (say) Dropbox, the changes in your project are not stored until you tell Git that they are ready to be stored i.e. in Git you 'commit' them.\n\nThe act of 'committing' in Git creates a 'version' (sometimes just called a 'commit'). A version can be thought of as a snapshot of your whole project at that time. Once a commit has been made, it's always possible to get back to this version. This simple concept can be extremely powerful for the evolution and maintenance of small to very large programming projects.\n\nEach version should be accompanied by a message describing the change made by the commit. This can be a skill in itself as you wish to tell your collaborators or your future self what changes have been made (we will discuss best practices in Unit 4).\n\n::: panel-tabset\n## Command-line\n\nNow let's create our first commit!\n\n```{bash eval=FALSE}\ngit commit --message \"Create poem.txt\"\n```\n\n```         \n[main (root-commit) acf18e1] Create poem.txt\n1 file changed, 16 insertions(+)\ncreate mode 100644 poem.txt\n```\n\nIf you do not specify a message then Git will open up your text editor of choice (see unit 1) to add a message.\n\nExperienced users will use the shorthand `-m` instead of `--message`, i.e. `git commit -m \"Create poem.txt\"`.\n\nGit status shows \"working tree clean\", which means all changes detected in the directory have been committed to Git:\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\nnothing to commit, working tree clean\n```\n\nLet's have our first look at the log:\n\n```{bash eval=FALSE}\ngit log\n```\n\n```         \ncommit acf18e19f0803fd405f7d1e196fbaf710066728d\nAuthor: David McArthur <david.mcarthur.2@glasgow.ac.uk>\nDate:   Mon Aug 21 13:41:25 2023 +0100\n\nCreate poem.txt\n```\n\nThere is a log of our first version! (Again this opens vim, and to exit press `:` followed by `q`).\n\n## GitHub Desktop\n\nMake sure the file is staged making sure the checkbox `poem.txt` is ticked, add the message \"Create poem.txt\" to the summary, then click the \"Commit to main\" button:\n\n![](images/image11.png)\n\nWe have created our first commit! GitHub Desktop now says we have \"No local changes\", which means all changes detected in the directory have been committed to Git:\n\n![](images/image12.png)\n\nWhere did our commit go? By clicking on the \"History\" tab, we can see our first commit:\n\n![](images/image13.png)\n:::\n\n## Get our project onto GitHub\n\nYou have now created a Git repository on your local machine and added a file, however this is only available to people who use your computer. In this section we will demonstrate how to make this available to everyone via the GitHub website.\n\n### Create a new repository on GitHub\n\nUp to this point, we have been using Git locally. Next, let's learn how to put a copy of our project on GitHub to share it with others or just make a backup for ourselves.\n\n::: callout-caution\n### **Private or Public Repository**\n\nWhen creating a GitHub repository, you will need to decide if it will be private or public. Private will mean the code is only available to yourself and other contributors, but public will mean that anyone will be able to see your code. The purpose and stage of your project will determine which of these makes the most sense.\n\nThe decision is ultimately a pragmatic one, and can strongly depend on your particular circumstances, for example, you may wish to develop a new open-source software library in a public repository to encourage interest and contributions from others earlier, or you may wish to keep it private either for your own use only or until it is ready to be shared. Approaches to this can also vary, in some parts of Academia it is common to having a public repository on active research projects, in others a repository is made public once the project has finished.\n\n**Important:**Â Be careful not to put anything sensitive on a public repository as it will be accessible to all, although it is probably not to put it on GitHub either way.\n:::\n\n::: panel-tabset\n## Command-line\n\nTo be able to add our content to a GitHub page (remote repository), you will firstly need to create a repository. GitHub Desktop does this for you, but for the command-line, we need to do it ourselves. You can do this by following the Create a repo quickstart guide to create a new repository for our example. Here it is named \"tutorial1\" but you can name it whatever you like.\n\nThe Git command for syncing local commits with GitHub is push. Let's try it now:\n\n```{bash eval=FALSE}\ngit push\n```\n\n```         \nfatal: No configured push destination.\nEither specify the URL from the command-line or configure a remote repository using\n\n    git remote add <name> <url>\n\nand then push using the remote name\n\n    git push <name>\n```\n\nGit is telling us we still need to configure our local repository to use our new GitHub repository as a remote (a remote is a copy of our repository stored in another location, in this case on GitHub). When we ask Git to list the configured remotes there is no output:\n\n```{bash eval=FALSE}\ngit remote\n```\n\n```         \norigin\n```\n\nSo let's set that up now.\n\nOn GitHub, copy the URL of your empty repository:\n\n![](images/image14.png)\n\nAnd paste it in the following command:\n\n```{bash eval=FALSE}\ngit remote add origin <your-repository-url>\n```\n\nYou can check `git remote` again:\n\n```{bash eval=FALSE}\ngit remote\n```\n\n```         \norigin\n```\n\n```{bash eval=FALSE}\ngit remote --verbose\n```\n\n```         \norigin  https://github.com/dmca-glasgow/tutorial1.git (fetch)\norigin  https://github.com/dmca-glasgow/tutorial1.git (push)\n```\n\nWe can see that our GitHub repository is configured for both fetch and push commands.\n\nNow let's try to push again:\n\n```{bash eval = FALSE}\ngit push\n```\n\n```         \nfatal: The current branch main has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin main\n\nTo have this happen automatically for branches without a tracking\nupstream, see 'push.autoSetupRemote' in 'git help config'.\n```\n\nGit is telling us it can't sync our local commits to main because GitHub doesn't know about the main branch yet. So let's follow its instructions to tell GitHub about this branch:\n\n```{bash eval = FALSE}\ngit push --set-upstream origin main\n```\n\n```         \nTo https://github.com/dmca-glasgow/tutorial1.git\n  * [new branch]      main -> main\nbranch 'main' set up to track 'origin/main'.\n```\n\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\n## Git-Desktop\n\nIn GitHub Desktop, click the \"Publish repository\" tab, give it a name, and click the \"Publish Repository\" button:\n\n![](images/image15.png)\n:::\n\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\n![](images/image16.png)\n\nWe can click on the commits icon:\n\n![](images/image17.png)\n\nTo view our commit history:\n\n![](images/image18.png)\n\nAnd we can click on the branches button to view our main branch:\n\n![](images/image19.png)\n\n## Updating your repository\n\nNow that we have a local Git repository that is linked to GitHub, let's briefly explore the process of updating our project.\n\n### Rename the file\n\nFirst, let's rename our `poem.txt` file to `poem.md` (for Markdown).\n\nIn Git terms, renaming a file is considered deleting one file (`poem.txt`) and creating a new file (poem.md).\n\n::: panel-tabset\n## Command-line\n\nYou can see that `poem.md` currently has 'untracked' status as it has not been added to Git yet.\n\n```{bash eval=FALSE}\ngit status\n```\n\n```         \nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n(use \"git add/rm <file>...\" to update what will be committed)\n(use \"git restore <file>...\" to discard changes in working directory)\ndeleted:    poem.txt\n\nUntracked files:\n(use \"git add <file>...\" to include in what will be committed)\npoem.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n## GitHub Desktop\n\nThe icon beside `poem.md` has a plus symbol for a new, untracked file, whereas the `poem.txt` file has a red minus symbol indicating it has been deleted.\n\n![](images/image19_1.png)\n:::\n\nNext, let's commit this change. It might seem counter-intuitive, but we need to stage and commit both files in this scenario because adding a file and deleting a file are both actions that need to be committed.\n\n::: panel-tabset\n## Command-line\n\nLet's do that now:\n\n```{bash eval = FALSE}\ngit add poem.txt poem.md\n```\n\n```         \ngit commit -m 'rename poem.txt to poem.md'\n[main edac35e] rename poem.txt to poem.md\n1 file changed, 0 insertions(+), 0 deletions(-)\nrename poem.txt => poem.md (100%)\n```\n\n## GitHub Desktop\n\n![](images/image20.png)\n:::\n\n# Supplement: Special file conventions\n\nBoth Git and GitHub have special file conventions, where files with a particular name have special behaviours. Git uses the 'dotfile' convention (a `.` at the start of the name), whereas GitHub typically uses all-caps. The 'dotfile' convention is relatively common and as your operating system may know that they are used as configuration files they may not show up in our file manager.\n\nThe most important are listed below, but please see a [list of Git special files](https://stackoverflow.com/questions/12605576#12719247) and a [list of GitHub special files](https://github.com/joelparkerhenderson/github-special-files-and-paths) for more information.\n\n## .gitignore\n\nWhen we share our codebase using Git and GitHub, either with the public or with colleagues, we can choose to exclude certain files (e.g. tell Git/GitHub never to consider them) by making use of a `.gitignore` file. To be more precise, we are telling Git to ignore these files from our project folder by not adding them to any commit change list.\n\n```{=html}\n<!--`.gitignore` files use a simple syntax to make it easy to match files. The entries in this file can also follow a matching pattern.\n\n-   `*` is used as a wildcard match\n-   `/` is used to ignore pathnames relative to the .gitignore file\n-   `#` is used to add comments to a .gitignore file-->\n```\n\nFor example:\n\n```         \n# <-- comments start with a hash sign\n# empty lines are ignored\n\n# ignore 'passwords.txt' at the root of your project:\n/passwords.txt\n\n# ignore 'passwords.txt' anywhere in your project:\npasswords.txt\n\n# ignore 'cache' folder  at the root of your project:\n/cache/\n\n# ignore all 'cache' folders:\ncache/\n\n# ignore all .log files inside a 'logs' folder:\nlogs/*.log\n\n# ignore all .html files inside the 'logs' folder including sub-folders:\nlogs/**/*.log\n\n# ignore all files with .log extension:\n**/*.log\n```\n\nIf a file has already been committed to Git, ignoring it with .gitignore won't remove it from the repository, only it's changes from that point on. If you'd like to remove a file from Git, the simplest way is to follow these steps:\n\n1.  Move the file out of your project folder\n2.  Git will treat the file as deleted. Stage and commit this change.\n3.  Add the file path to .gitignore\n4.  Move the file back into your project folder\n5.  Check the stage and confirm that Git is ignoring it\n6.  Commit the updated .gitignore file\n\nHowever, while the file has been removed it is still present in your history in future sections.\n\n## .gitkeep\n\nA strange quirk of Git is that it is only concerned with files and not folders. Your project can be split into as many files and folders as you wish with no problems, but at some point, you may be confused that Git does not 'see' empty folders.\n\nAs a workaround, a common convention is to create an empty file inside the folder named `.gitkeep`, which you can commit, enabling you to store the (not really) empty folder in your repository.\n"},"formats":{"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"index.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"editor":"visual","title":"Week 4: Collaborative Coding 1","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"selfContainedOutput":true}}},"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":"cosmo","title":"Week 4: Collaborative Coding 1","editor_options":{"chunk_output_type":"console"},"toc-location":"left","toc-title":"Contents"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}