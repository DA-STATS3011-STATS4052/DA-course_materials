[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Week 4: Collaborative Coding 1",
    "section": "",
    "text": "This week’s material is based on the Version Control Course from the School of Mathematics and Statistics from the University of Glasgow. The content has been reduced to fit the class structure. At the end of Week 5, please provide some feedback on the materials on https://uofg.qualtrics.com/jfe/form/SV_56jF2LNgmA6qrhY."
  },
  {
    "objectID": "index.html#what-is-a-version-control-system",
    "href": "index.html#what-is-a-version-control-system",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n1.1 What is a version control system",
    "text": "1.1 What is a version control system\nA Version Control System is a tool that helps keep track of code and software development projects as they change over time. The idea is to save snapshots of code at any given time, called versions, to allow developers to understand how the code was developed and if necessary revert (go back) to previous versions.\nWhen coding collaboratively researchers or developers can work on the same code base, keeping individual versions of the code separate from each other. These different sections are called branches, which you’ll learn about in this course, can later be combined by the system such that code that has stayed the same remains unchanged and changes made by each researcher or developer can be combined into one version."
  },
  {
    "objectID": "index.html#separate-instructions-for-the-command-line-and-github-desktop",
    "href": "index.html#separate-instructions-for-the-command-line-and-github-desktop",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n2.1 Separate instructions for the command line and GitHub Desktop",
    "text": "2.1 Separate instructions for the command line and GitHub Desktop\nAs with any tool, there are multiple ways of interacting with it and individuals tend to choose the way that works best for them/their workflow. Two of the most common ways of interacting with git/version control is either through the command line using the ‘git’ command or through a graphical user interface (GUI).\nTo address both needs throughout this course, you can either work through the examples using the command line or GitHub Desktop - a popular GUI (or compare both) for using Git. When you see a section that has a border around it, you can select either ‘Command-line’ or ‘GitHub Desktop’ at the top, and this will change all sections on the page to your preferred program."
  },
  {
    "objectID": "index.html#installation-and-command-line-usage",
    "href": "index.html#installation-and-command-line-usage",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n2.2 Installation and command-line usage",
    "text": "2.2 Installation and command-line usage\nAs Git is primarily a developer tool, it may be a little harder to install than you are used to. Git is a command-line program, however, you can opt to install a graphical user interface (GUI) for Git such as GitHub Desktop and avoid having to open a command-line terminal at all if you don’t want to!\nIf you’re familiar with installing command-line tools, GitHub provides a short guide named Install Git that should get you up and running quickly.\nBelow are some additional tips for those needing a bit more guidance.\n\n2.2.1 For Mac users\nGit is a command-line tool that is usually already installed on Macs and can be accessed from the built-in terminal. The Terminal application can be found by navigating to the Applications/Utilities folder or searching for ‘Terminal’ in Spotlight.\n\n2.2.2 For Windows users\nThis Getting Started guide provides a bit more detail on which options to select during the installation process for the best experience.\nAfter clicking the “Download Git for Windows” button you will arrive at a GitHub Release page, with lots of variations to choose from.\nTo know which option is right for your system, first, you need to find out if your computer is 32-bit or 64-bit:\nGo to Start &gt; Settings &gt; System &gt; About. Check the bit version under Device specifications &gt; System type.\nThen choose the .exe file that matches your system:\n\nOnce installed, it can be accessed from the Git Bash terminal which comes included as part of the Git For Windows package. You can find Git Bash by opening the Start menu and typing ‘Git Bash’ into the search bar. However, if you plan on using a GUI for Git such as GitHub Desktop, you don’t need to open a terminal at all."
  },
  {
    "objectID": "index.html#set-your-git-name-and-email-address",
    "href": "index.html#set-your-git-name-and-email-address",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n5.1 Set your Git Name and Email address",
    "text": "5.1 Set your Git Name and Email address\nGit needs a name and email address to attach to your commit signature (a bit like an email signature). Let’s set this up now, and be sure to use the same email address that you use to sign into GitHub.\n\n\nCommand-line\nGitHub Desktop\n\n\n\n\nCodegit config --global user.name \"Your Name\"\n\ngit config --global user.email \"youremail@yourdomain.com\"\n\n\nOnce done, you can confirm that the information is set by running:\n\nCodegit config --list\n\n\nAnd should see output similar to this:\nuser.name=Your Name\nuser.email=youremail@yourdomain.com\n\n\nFrom the main menu, select GitHub Desktop &gt; Settings... . In the settings pane, select ‘Git’ from the sidebar:"
  },
  {
    "objectID": "index.html#process-outline",
    "href": "index.html#process-outline",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n8.1 Process Outline",
    "text": "8.1 Process Outline\nOne way to think about a Git/GitHub project is a folder on your local computer which is version controlled and potentially (also) on GitHub.\nTo set up this structure, the workflow we are going to look at next is creating a local project folder, adding a file, initialising Git, and then saving a copy to Github. It’s also a valid workflow to first create a GitHub repository, then ‘clone’ it to your computer (see Unit 3).\nAs part of this course, you can either follow the instructions for Command-line or GitHub Desktop. Simply choose the tab you want below and all sections will change to the desired format. For example, the outline of the workflow is different for the two options, as GitHub Desktop automates some of the tasks:\n\n\nCommand-line\nGitHub Desktop\n\n\n\n\nCreate a local repository\nCreate a new file\nAdd the file to the Git ‘stage’\nCommit the file\nCreate a new repository on GitHub\nConfigure our local repository to point to the new GitHub repository as a remote ‘origin’\nPush our commit(s) to sync them with the repository on GitHub.\n\n\n\n\nCreate a local repository\nCreate a file\nCommit the file\nPublish the repository on GitHub.\n\n\n\n\nFinally, we are going to look at how you update this file. This essentially follows the same process where we:\n\nUpdate the file (or add one)\nAdd the changes\nCommit the changes\nPush the changes"
  },
  {
    "objectID": "index.html#create-a-local-git-repository",
    "href": "index.html#create-a-local-git-repository",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n8.2 Create a local Git repository",
    "text": "8.2 Create a local Git repository\nFirst we need to create a local Git repository which will allow us to work through this tutorial. Ensure you have Git installed (see the ‘Installation and command-line usage’ section).\n\n\nCommand-line\nGitHub Desktop\n\n\n\nCreate an empty folder on your computer using mkdir and then change to that directory using cd:\n\nCodemkdir tutorial1\n\n\nAlternatively as we will create several tutorials throughout this course you may wish to first create a folder to contain them and then create the folder for the first tutorial.\nThen run git init to initialise Git inside the folder:\n\nCodecd tutorial1\ngit init\n\n\nInitialized empty Git repository in /Users/staff/Work/tutorial1/.git/\nThe git init command turns a simple folder into a Git repository.\n\n\nChoose File &gt; New Repository... from the menu.\nIn the “Create a New Repository” form, name the repository “tutorial1”, set the “Local Path” field to your preferred location and click the “Create Repository” button:\n\n\n\n\nThat’s it! You now have a local Git repository running in this folder. We will come back and learn more about the settings for the README, Git Ignore, and License later on in the course. We can now visualise our new git repository, however as we have not added anything to our git it is currently empty.\nGit has created a new folder inside your folder called .git. You may not be able to see this folder on a Mac or Windows operating system, as it is a convention for files and folders that start with a . to be hidden by default. However, it is important to know that the folder is there, as it holds information that is necessary for Git to function correctly. This folder should not be manually edited, instead, you should use Git commands which in turn update the information here. If you decide to move all your files to another folder for some reason, be careful to also move this .git folder if you want to keep using your Git repository!\nIn the Finder on MacOS you can show hidden files using the following keyboard shortcut:\n\nCodeShift + Command + \".\"\n\n\nIn File Explorer on Windows, select:\n\nCodeView &gt; Show &gt; Hidden items."
  },
  {
    "objectID": "index.html#create-a-file",
    "href": "index.html#create-a-file",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n8.3 Create a file",
    "text": "8.3 Create a file\nNow let’s add a file. Of course, this would usually be code, configuration, or documentation files, but to keep this course somewhat generic and avoid distracting programming concepts, let’s add a short poem in a plain text file poem.txt to the folder. You should use your preferred Code Editor to create the file, such as VSCode or RStudio. If using Word or other “rich text” editors ensure you choose the File Format “Plain text (.txt)” when saving the file.\nEnsure the file is saved. Git can only ‘see’ changes that are saved.\n\n\n\n\n\n\npoem.txt\n\n\n\nNow We Are Six by A. A. Milne\nWhen I was One,\nI had just begun.\nWhen I was Two,\nI was nearly new.\nWhen I was Three\nI was hardly me.\nWhen I was Four,\nI was not much more.\nWhen I was Five,\nI was just alive.\nBut now I am Six,\nI’m as clever as clever,\nSo I think I’ll be six now for ever and ever.\n\n\nEnsure the file is saved. Git can only ‘see’ changes that are saved."
  },
  {
    "objectID": "index.html#git-status",
    "href": "index.html#git-status",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n8.4 Git status",
    "text": "8.4 Git status\n\n\nCommand-line\nGitHub Desktop\n\n\n\nLet’s have our first look at the output of git status.git status tries to provide helpful information depending on your current situation.\nWhen using Git, you’ll run git status so often that it will soon become muscle memory! The git status command only outputs status information and won’t modify commits or changes in your local repository.\nNow we’ve created a file let’s see what it outputs:\n\nCodegit status\n\n\nOn branch main\n\nNo commits yet\n\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\npoem.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\nWe can see that Git knows we’re on the main branch (we’ll introduce branching concepts gradually as we progress through the course).\nThere have been no commits yet (more on this later in this unit).\nGit knows our poem.txt file has been created but it is still “untracked” (a version has not been explicitly added to Git yet and therefore this file is not covered by version control)\n\nThe --short or -s flag removes all but the most relevant information:\n\nCodegit status -s\n\n\n?? poem.txt\nHere we can see the Git shortened syntax for “untracked” is ??.\n\n\nLet’s have a look at GitHub Desktop. As you work on your project GitHub Desktop will watch your files update when it detects changes:\n\nHere we can see Git has found our new file! We have added some numbered purple circles to the screenshot above, let’s go through those areas:\n\nHere we can see that Git knows we’re on the main branch (we’ll introduce branching concepts gradually as we progress through the course).\nIf you click on the History tab, you’ll see there have been no commits yet (more on this later in this unit).\nThe checkbox beside the filename is checked, which in Git terms, means the file has been “staged” for commit"
  },
  {
    "objectID": "index.html#adding-our-file-to-our-project",
    "href": "index.html#adding-our-file-to-our-project",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n8.5 Adding our file to our project",
    "text": "8.5 Adding our file to our project\n\n8.5.1 Stage the file\nAdding files to the stage is an intermediate step before committing to a version. We need to choose (stage) the files we want to add to our commit. Staging may seem an unnecessary step at this point, but later we will demonstrate how this can be a powerful tool.\nFor now, we will stage all changes, our only file poem.txt.\n\n\nCommand-line\nGitHub Desktop\n\n\n\nWe can stage the file using the add command:\n\nCodegit add poem.txt\n\n\nNote that there two options here: * git add &lt;path&gt;: Stage a specific directory or file * git add .: Stage all files (that are not listed in the .gitignore) in the entire repository.\nNow we’ve staged the file let’s have a look at the status again:\n\nCodegit status\n\n\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached &lt;file&gt;...\" to unstage)\nnew file:   poem.txt\nOur poem.txt file has been added to the stage! If we view the short version we can see A for “add”:\n\nCodegit status -s\n\n\nA  poem.txt\nThere is also a --verbose or -v flag. In this case, it also includes the “diff” of poem.txt (more information on what a “diff” is after this example):\n\nCodegit status --verbose\n\n\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached &lt;file&gt;...\" to unstage)\nnew file:   poem.txt\n\ndiff --git a/poem.txt b/poem.txt\nnew file mode 100644\nindex 0000000..12f4ac3\n--- /dev/null\n+++ b/poem.txt\n@@ -0,0 +1,16 @@\n+Now We Are Six by A. A. Milne\n+\n+When I was One,\n+I had just begun.\n+When I was Two,\n+I was nearly new.\n+When I was Three\n+I was hardly me.\n+When I was Four,\n+I was not much more.\n+When I was Five,\n+I was just alive.\n+But now I am Six,\n+I'm as clever as clever,\n+So I think I'll be six now for ever and ever.\n+\nWe can view this “diff” output on its own using the command in the next box.\n\n\n\nGitHub Desktop has automatically added our new file to the stage as you can see by the checked checkbox.\nThe green plus symbol here indicates this is a new file (or technically, it has not been added to Git yet).\nThis area displays the “diff” of poem.txt (more information on what a “diff” is after this example).\n\n\n\n\n\n\n8.5.2 Commit the first version\nOnce we have determined which files we want to stage, we can then commit the change(s). Importantly unlike (say) Dropbox, the changes in your project are not stored until you tell Git that they are ready to be stored i.e. in Git you ‘commit’ them.\nThe act of ‘committing’ in Git creates a ‘version’ (sometimes just called a ‘commit’). A version can be thought of as a snapshot of your whole project at that time. Once a commit has been made, it’s always possible to get back to this version. This simple concept can be extremely powerful for the evolution and maintenance of small to very large programming projects.\nEach version should be accompanied by a message describing the change made by the commit. This can be a skill in itself as you wish to tell your collaborators or your future self what changes have been made (we will discuss best practices in Unit 4).\n\n\nCommand-line\nGitHub Desktop\n\n\n\nNow let’s create our first commit!\n\nCodegit commit --message \"Create poem.txt\"\n\n\n[main (root-commit) acf18e1] Create poem.txt\n1 file changed, 16 insertions(+)\ncreate mode 100644 poem.txt\nIf you do not specify a message then Git will open up your text editor of choice (see unit 1) to add a message.\nExperienced users will use the shorthand -m instead of --message, i.e. git commit -m \"Create poem.txt\".\nGit status shows “working tree clean”, which means all changes detected in the directory have been committed to Git:\n\nCodegit status\n\n\nOn branch main\nnothing to commit, working tree clean\nLet’s have our first look at the log:\n\nCodegit log\n\n\ncommit acf18e19f0803fd405f7d1e196fbaf710066728d\nAuthor: David McArthur &lt;david.mcarthur.2@glasgow.ac.uk&gt;\nDate:   Mon Aug 21 13:41:25 2023 +0100\n\nCreate poem.txt\nThere is a log of our first version! (Again this opens vim, and to exit press : followed by q).\n\n\nMake sure the file is staged making sure the checkbox poem.txt is ticked, add the message “Create poem.txt” to the summary, then click the “Commit to main” button:\n\nWe have created our first commit! GitHub Desktop now says we have “No local changes”, which means all changes detected in the directory have been committed to Git:\n\nWhere did our commit go? By clicking on the “History” tab, we can see our first commit:"
  },
  {
    "objectID": "index.html#get-our-project-onto-github",
    "href": "index.html#get-our-project-onto-github",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n8.6 Get our project onto GitHub",
    "text": "8.6 Get our project onto GitHub\nYou have now created a Git repository on your local machine and added a file, however this is only available to people who use your computer. In this section we will demonstrate how to make this available to everyone via the GitHub website.\n\n8.6.1 Create a new repository on GitHub\nUp to this point, we have been using Git locally. Next, let’s learn how to put a copy of our project on GitHub to share it with others or just make a backup for ourselves.\n\n\n\n\n\n\nPrivate or Public Repository\n\n\n\nWhen creating a GitHub repository, you will need to decide if it will be private or public. Private will mean the code is only available to yourself and other contributors, but public will mean that anyone will be able to see your code. The purpose and stage of your project will determine which of these makes the most sense.\nThe decision is ultimately a pragmatic one, and can strongly depend on your particular circumstances, for example, you may wish to develop a new open-source software library in a public repository to encourage interest and contributions from others earlier, or you may wish to keep it private either for your own use only or until it is ready to be shared. Approaches to this can also vary, in some parts of Academia it is common to having a public repository on active research projects, in others a repository is made public once the project has finished.\nImportant: Be careful not to put anything sensitive on a public repository as it will be accessible to all, although it is probably not to put it on GitHub either way.\n\n\n\n\nCommand-line\nGit-Desktop\n\n\n\nTo be able to add our content to a GitHub page (remote repository), you will firstly need to create a repository. GitHub Desktop does this for you, but for the command-line, we need to do it ourselves. You can do this by following the Create a repo quickstart guide to create a new repository for our example. Here it is named “tutorial1” but you can name it whatever you like.\nThe Git command for syncing local commits with GitHub is push. Let’s try it now:\n\nCodegit push\n\n\nfatal: No configured push destination.\nEither specify the URL from the command-line or configure a remote repository using\n\n    git remote add &lt;name&gt; &lt;url&gt;\n\nand then push using the remote name\n\n    git push &lt;name&gt;\nGit is telling us we still need to configure our local repository to use our new GitHub repository as a remote (a remote is a copy of our repository stored in another location, in this case on GitHub). When we ask Git to list the configured remotes there is no output:\n\nCodegit remote\n\n\norigin\nSo let’s set that up now.\nOn GitHub, copy the URL of your empty repository:\n\nAnd paste it in the following command:\n\nCodegit remote add origin &lt;your-repository-url&gt;\n\n\nYou can check git remote again:\n\nCodegit remote\n\n\norigin\n\nCodegit remote --verbose\n\n\norigin  https://github.com/dmca-glasgow/tutorial1.git (fetch)\norigin  https://github.com/dmca-glasgow/tutorial1.git (push)\nWe can see that our GitHub repository is configured for both fetch and push commands.\nNow let’s try to push again:\n\nCodegit push\n\n\nfatal: The current branch main has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin main\n\nTo have this happen automatically for branches without a tracking\nupstream, see 'push.autoSetupRemote' in 'git help config'.\nGit is telling us it can’t sync our local commits to main because GitHub doesn’t know about the main branch yet. So let’s follow its instructions to tell GitHub about this branch:\n\nCodegit push --set-upstream origin main\n\n\nTo https://github.com/dmca-glasgow/tutorial1.git\n  * [new branch]      main -&gt; main\nbranch 'main' set up to track 'origin/main'.\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\n\nIn GitHub Desktop, click the “Publish repository” tab, give it a name, and click the “Publish Repository” button:\n\n\n\n\nAnd now, if we refresh our GitHub repository page, we should see our poem.txt file!\n\nWe can click on the commits icon:\n\nTo view our commit history:\n\nAnd we can click on the branches button to view our main branch:"
  },
  {
    "objectID": "index.html#updating-your-repository",
    "href": "index.html#updating-your-repository",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n8.7 Updating your repository",
    "text": "8.7 Updating your repository\nNow that we have a local Git repository that is linked to GitHub, let’s briefly explore the process of updating our project.\n\n8.7.1 Rename the file\nFirst, let’s rename our poem.txt file to poem.md (for Markdown).\nIn Git terms, renaming a file is considered deleting one file (poem.txt) and creating a new file (poem.md).\n\n\nCommand-line\nGitHub Desktop\n\n\n\nYou can see that poem.md currently has ‘untracked’ status as it has not been added to Git yet.\n\nCodegit status\n\n\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n(use \"git add/rm &lt;file&gt;...\" to update what will be committed)\n(use \"git restore &lt;file&gt;...\" to discard changes in working directory)\ndeleted:    poem.txt\n\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\npoem.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\nThe icon beside poem.md has a plus symbol for a new, untracked file, whereas the poem.txt file has a red minus symbol indicating it has been deleted.\n\n\n\n\nNext, let’s commit this change. It might seem counter-intuitive, but we need to stage and commit both files in this scenario because adding a file and deleting a file are both actions that need to be committed.\n\n\nCommand-line\nGitHub Desktop\n\n\n\nLet’s do that now:\n\nCodegit add poem.txt poem.md\n\n\ngit commit -m 'rename poem.txt to poem.md'\n[main edac35e] rename poem.txt to poem.md\n1 file changed, 0 insertions(+), 0 deletions(-)\nrename poem.txt =&gt; poem.md (100%)"
  },
  {
    "objectID": "index.html#gitignore",
    "href": "index.html#gitignore",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n9.1 .gitignore",
    "text": "9.1 .gitignore\nWhen we share our codebase using Git and GitHub, either with the public or with colleagues, we can choose to exclude certain files (e.g. tell Git/GitHub never to consider them) by making use of a .gitignore file. To be more precise, we are telling Git to ignore these files from our project folder by not adding them to any commit change list.\n\nFor example:\n# &lt;-- comments start with a hash sign\n# empty lines are ignored\n\n# ignore 'passwords.txt' at the root of your project:\n/passwords.txt\n\n# ignore 'passwords.txt' anywhere in your project:\npasswords.txt\n\n# ignore 'cache' folder  at the root of your project:\n/cache/\n\n# ignore all 'cache' folders:\ncache/\n\n# ignore all .log files inside a 'logs' folder:\nlogs/*.log\n\n# ignore all .html files inside the 'logs' folder including sub-folders:\nlogs/**/*.log\n\n# ignore all files with .log extension:\n**/*.log\nIf a file has already been committed to Git, ignoring it with .gitignore won’t remove it from the repository, only it’s changes from that point on. If you’d like to remove a file from Git, the simplest way is to follow these steps:\n\nMove the file out of your project folder\nGit will treat the file as deleted. Stage and commit this change.\nAdd the file path to .gitignore\nMove the file back into your project folder\nCheck the stage and confirm that Git is ignoring it\nCommit the updated .gitignore file\n\nHowever, while the file has been removed it is still present in your history in future sections."
  },
  {
    "objectID": "index.html#gitkeep",
    "href": "index.html#gitkeep",
    "title": "Week 4: Collaborative Coding 1",
    "section": "\n9.2 .gitkeep",
    "text": "9.2 .gitkeep\nA strange quirk of Git is that it is only concerned with files and not folders. Your project can be split into as many files and folders as you wish with no problems, but at some point, you may be confused that Git does not ‘see’ empty folders.\nAs a workaround, a common convention is to create an empty file inside the folder named .gitkeep, which you can commit, enabling you to store the (not really) empty folder in your repository."
  },
  {
    "objectID": "about.html#download-a-.zip-package",
    "href": "about.html#download-a-.zip-package",
    "title": "Week 4 Tasks",
    "section": "Download a .zip package",
    "text": "Download a .zip package\nThe most straightforward method is to download a .zip file containing the latest version of the files.\n\nClick on the green ‘Code’ button, then the ‘Download ZIP’ option. This will download a single file, archived and compressed using the common ZIP file format. Double-clicking the file will extract its contents to a folder next to the original .zip file.\nAn important distinction here is that you are downloading just the codebase — the files and folders of the repository — and not the Git repository itself. This means you lose some of the key functionality of Git, for example, if the project maintainers make any updates to the project, you will need to manually re-download the .zip file and extract it again to see those changes, instead of being able to easily pull these changes (more on this in the next example!)."
  },
  {
    "objectID": "about.html#clone",
    "href": "about.html#clone",
    "title": "Week 4 Tasks",
    "section": "Clone",
    "text": "Clone\nAnother way to download a project to your computer is to use Git’s clone method. To use clone, we need to tell Git installed on our computer to make a copy (or ‘clone’) of another repository, in this case from GitHub.\n\nCommand-lineGitHub Desktop\n\n\nFirst, we need to copy the address of the repository we want to clone.\n\n\nClick on the green button labelled “Code”\nChoose either HTTPS or SSH, depending on how you connect to GitHub with Git on your computer (see the Configuration section of Unit 1)\nCopy the address\n\nThen in your terminal, navigate to your desired folder and issue the following command:\n\ngit clone &lt;address&gt;\n\nYou should now see the repository has been cloned to your computer.\n\n\nFirst, navigate to the repository you want to clone on the GitHub website.\n\n\nClick on the green button labelled ‘Code’\nClick on ‘Open with GitHub Desktop’\nYou should then see a window like this pop up in GitHub Desktop:\n\n\n\nThe URL of the repository on GitHub has automatically been populated\nChoose where you would like the repository to be cloned to on your computer\nClick ‘Clone’\n\n\n\n\nUsing this approach, we have a copy of the files and folders in the repository, but we have also copied the metadata which makes this into a Git repository. To answer the example above, now if a project maintainer makes an update to the project on GitHub, we can easily sync both versions:\n\nCommand-lineGitHub Desktop\n\n\nIn the project folder just issue the pull command:\n\ngit pull\n\n\n\nOn GitHub Desktop, click the ‘Fetch origin’ button in the top bar:"
  }
]